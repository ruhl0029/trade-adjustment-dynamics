/***************************************************

   GAUSS Prgram for George Alessandria, Horag Choi, and Kim J. Ruhl (2020) 
   "Trade Adjustment Dynamics and the Welfare Gains from Trade," Working Paper

   NOCOST MODEL UNILATERAL TRADE LIBERALIZATION WITH A SINGLE BOND
	 
	 The program is run with a guessed terminal bond holdings, B(T).
	 Then, the initial bond holding is computed using the budget constraint backward.
	 The terminal bond holdings, B(T), needs to be manually searched to get B(0)=0.
     
   The program is written for GAUSS version 5.0
     
   The program computes the transition dynamics of the economy.
   The program requires 
      i) non-linear system equations package (nlsys.set and nlproc.arc, Lee Edlefsen  3/29/86) and 
      ii) Optimization application
   For newer versions of these applications, you may need to modify the program where they are applied.
     
   Revised Date: 17 November 2020
     
 ***************************************************/
new;cls;
output file = Uni_NoCost_Bond01.out reset;

library  optmum, pgraph;
#include nlsys.set;
#include olss.src;
rndseed 123456;

di   = 1e-8;             @ convergence tolerence @
/*===========================================================*
 * Variables for the Solutions of Nonlinear System Equations *
 *===========================================================*/
    convtol=di;          @ convergence tolerance.                  @
    prntit=0;            @ if 1 will print on every iteration @
    prntout=0;           @ if 1, will print final output;
                         NOTE: the solution vector is always
                               assigned to x1, and will be in memory when
                               the program is completed.               @
    fname=&f;            @ change this if the name of the proc
                           containing the functions is not = f     @
    gradname=&grad1;     @ change this tO specify another proc to 
                           compute the Jacobian matrix, if desired.@ 
    jc0=0;               @ change this to specify a KxK matrix to be
                           used as the initial value of the Jacobian,
                           if desired.                             @ 
    fname=&f;
/*===========================================================*/
format /rdn 20,8;

@ benchmark (no fixed cost in production) S and trade elasticity @
S =   1.00810680;
lambda = 0.91299899;
elas   = 12.86717856;

@ RhoHL @
S      = 1.00811039;
lambda = 0.91150348;
elas   = 11.54751853;


fi =23.74198748;
rhog = 0.25230639;  @ persistence of g @

bet  = 0.96;               @ time discount factor @
thA  = elas+1;               @ elasticity of substitution b/w varieties @
th   = 5;
sig  = 2;                  @ CRRA @
gam  = 0.3;                @ No need here: labor share parameter @

del  = 0.10;               @ capital depreciation rate @

alp0 = 0.34;               @ target 1-labor share of VA @
alp  = 0.218;              @ To be corrected: 1- labor sahre of VA @
alpm = (1 - 1/2.8)*th/(th-1);  @ to be corrected: material share parameter: Matching MFR-output/MFR-VA = 2.8 @
alpm = 0.81008870;  @ check line 320 @

L0ss = 1;                  @ SS Labor supply: Exogenous @
L    = 1;

lamD  = 5.51;               @ To be calibrated:  prob of death slope parameter @
n_x0  = 0.223;              @ exporter ratio @
n_10  = 0.17;               @ Stopper rate @
n_00  = 0.10;               @ To be set: Starter rate @
Exit50= 0.37;               @ 5-year exit rate in the data @
prob0 = 0.20;               @ Entrant's shutdown probability due to fixed cost in production @
Ld00 = 0.023;               @ shutdown plant's labor share @
Ly00 = 0.015;               @ entrant's labor share @

eei0 = 0.133;              @ Export intensity @
eei5 = eei0*1;             @ 5 year exporter's expected intensity @
ta0  = 1.1;               @ Initial gross tariff rate @
ta1  = 1.0;                @ new tariff rate @
ta   = ta0;                @ initial tariff rate @
xi  = ( eei0/(1-eei0)*ta^thA )^(1/(1-thA));  @ iceberg cost @
xiH  = ( eei0/2/(1-eei0/2)*ta^thA )^(1/(1-thA));  @ iceberg cost of H set to be 0.5*eei0 @

xiL = 1.1;                 @ to be corrected: to get the average intensity @
rhoH = 0.96976;            @ to be corrected: to get the intensity in 5 years: 1/(1-rho) = E(waiting time) @
rhoL = 1;            @ to be corrected: to get the intensity in 5 years: 1/(1-rho) = E(waiting time) @

xi = (  (S-1)/(ta-1)*ta^thA/( 1 - (S-1)/(ta-1) ) )^(1/(1-thA));  @ iceberg cost @
xi = (1/lambda-1)^(1/(1-thA))*ta;
xiH = xi;
xiL = xiH;
rho = 0.5;

tiL = ( 1 + ta^(-thA)*xiL^(1-thA) ); @ to be corrected: multiplier for exporters @
tiH = ( 1 + ta^(-thA)*xiH^(1-thA) ); @ to be corrected: multiplier for exporters @

@ Total employees in MFR: 16948.9*1000 @
@ # of MFR producers: 370912 @
L1992 = 16948.9*1000;
E1992 = 370912;

pmfe_dat =    @ Establishment Data @
0.348044819|
0.178063799|
0.153149534|
0.152720861|
0.075600142|
0.058779441|
0.021021159|
0.008449444|
0.003248749|
0.000922052;
pmfl_dat =     @ employment Data @
0.013334041|
0.025977781|
0.046173543|
0.104383124|
0.116112360|
0.197957414|
0.158763592|
0.125210188|
0.105639827|
0.106448130;

pmfx_dat =  @ export participation rate @
          19.7450|
          40.4419|
          53.5769|
          61.9534|
          72.6595|
          79.2398;
pmfx_dat = pmfx_dat/100;

muE =  0.34084489;       @ entrants' disadvantage @
nd0 =  0.02176593;       @ constant shut-down shock @

f_0 = 2.99979829;        @ normalized startup cost @
f_1 = 1.20521080;        @ normalized continuation cost @

distwgt = 10; @ search weight (1/distwgt) for distribution @
distwgt = 20; @ search weight (1/distwgt) for distribution @
ndistwgt = 10; @ search weight (ndistwgt) for others @

   rhoLH = 0;

   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     1.16940256; f_1  =     1.10597928;
   xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000; @ RMSE           0.50161358 @
   
   sde =     1.31600000; rho =     0.65442341;  muE =     1.34365879;
   lamD=    20.93167832; nd0 =     0.02256872;  f_T =     0.00000000;  f_0 =     1.15626730; f_1  =     1.09521275;
   xiL =     1.17528650; xiH =     1.71823402; rhoH =     0.89040066; rhoL =     1.00000000; @ RMSE           0.50374691 @

   sde =     1.32400000; rho =     0.65442341;  muE =     1.34432421;
   lamD=    21.17754558; nd0 =     0.02258207;  f_T =     0.00000000;  f_0 =     1.18270149; f_1  =     1.11686863;
   xiL =     1.17439721; xiH =     1.71823402; rhoH =     0.89081152; rhoL =     1.00000000; @     RMSE           1.10914937 @

   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     1.16940256; f_1  =     1.10597928;
   xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000; @ RMSE           0.50161358 @

   sde =     1.32000000; rho =     0.65442341;  muE =     1.34291214;
   lamD=    21.04284098; nd0 =     0.02258301;  f_T =     0.00000000;  f_0 =     0; f_1  =     0;@ RMSE           0.50161358 @
   @xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000;@ 

xi = (  (S-1)/(ta-1)*ta^thA/( 1 - (S-1)/(ta-1) ) )^(1/(1-thA));  @ iceberg cost @
xi = (1/lambda-1)^(1/(1-thA))/ta;
xiH = xi;
xiL = xiH;
rhoH = 0.5;
rhoL = 0.5;

tiL = ( 1 + ta^(-thA)*xiL^(1-thA) ); @ to be corrected: multiplier for exporters @
tiH = ( 1 + ta^(-thA)*xiH^(1-thA) ); @ to be corrected: multiplier for exporters @

clear zp0, vxiL, x1, tiH, tiL, sdz, nodes, inprob, y1, yN, ome, zs, zsL, P, j, k, unP, i, unP2, D_E, para1,paras, eei;
clear dH, dL, ip, dH, dL, Eintensity;
clear V0HL, V0, VH, VL, msp0, mspH, mspL, EV0, EVH, EVL, EV0f, EVHf, EVLf, V0_new, VH_new, VL_new;
clear zp0, fracp0, idxp0, zpH, fracpH, idxpH, zpL, fracpL, idxpL, z0, frac0, idx0, zH, fracH, idxH, zL, fracL, idxL;
clear DV0, DVH, DVL, z0, frac0, idx0, ms0, zH, fracH, idxH, msH, zL, fracL, idxL, msL;
clear m0, mH, mL, DT0, DT1, DTH, DTL, iter, DT00, DT01, DTH0, DTH1, DTL0, DTL1, DT0new, DTHnew, DTLnew, tol;
clear SD0, SD01, SD10, SD1H, SD1L, n_0, n_1, n_X; 
clear DE0s, DEHs, DELs, DE00, DE01, DEH0, DEH1, DEL0, DEL1, DE0new, DEHnew, DELnew, Exit5; 
clear Int0, IntH, IntL, IntT, eei, L_0, L_L, L_H, L_T, Ly0, DDT00, DDT01, DDTH0, DDTH1, DDTL0, DDTL1, Ld0, shutdown;
clear wgtL, L_0D, L_LD, L_HD, L_cof, i, L_cmfe, L_cmfl, L_pmfe, L_pmfl, L_cofx, L_cmf3, L_cmf4, L_cmfx, L_pmf3, L_pmf4, L_pmfx;
clear vft01, Eintensityall, EEi00;

@----  producing output values given parameters  ----@ 
@ Given parameter values computes distributions      @
@ to match        @
@----------------------------------------------------@


para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

@---------------------------------------------------------@
@---  Calibration of productivity parameters -------------@
@---------------------------------------------------------@
/*
Xss0 = ln((f_0-f_1)|f_1|rhoH|xiH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoHxiH,Xss0);


Xss0 = ln((f_0-f_1)|f_1|rhoH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoH,Xss0);

Xss0 = ln(lamD|nd0|muE);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&lamndmu,Xss0);


Xss0 = ln((f_0-f_1)|f_1);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01,Xss0);


Xss0 = ln((f_0-f_1)|f_1|rhoH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoH,Xss0);



Xss0 = ln((f_0-f_1)|f_1|lamD|rhoH|nd0|muE);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01all1,Xss0);


Xss0 = ln((f_0-f_1)|f_1|lamD|rhoH|nd0|muE|(1-rho));
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&Paraall,Xss0);
*/




format /rdn 15,8;
?;
?;
?"   sde =";;sde;;"; rho =";;rho;;";  muE =";;muE;;";";
?"   lamD=";;lamD;;"; nd0 =";;nd0;;";  f_T =";;f_T;;";  f_0 =";;f_0;;"; f_1  =";;f_1;;";";
?"   xiL =";;xiL;;"; xiH =";;xiH;;"; rhoH =";;rhoH;;"; rhoL =";;rhoL;;";";
?;
?"   Note: Here f_0 and f_1 are normalized costs ";
?;

format /rdn 20,3;
?"    ---------------------------------------------------";
?"    ---------- 5 Parameters f0, f1, muE, nd0, lamD ----";
?"    ---------- selected to match ----------------------";
?"    ---------------------------------------------------";
?"    Entrants' labor share            (1.5%) ";;Ly0/L_T*100;
?"    Shutdown plants' labor share     (2.3%) ";;Ld0/L_T*100;
?"    Exporter Export Intensity: xi    (13.3%)";;eei*100;
?"    Stopper rate: n1                 (17.0%)";;0*100;
?"    Exporter rate: nx                (22.3%)";;1*100;
?"    Entrants' 5-year exit rate       (37.0%)";;Exit5*100;
?;
?"    f_T for Prob(Entrant in produciton)(80%)";;(1-cdfn((zp0+muE)/sdz))*100;
?;
?"    AND the DISTRIBUTIONS BELOW";
?;
?;

format /rdn 20,8;
?"    ------------ Establishments ------------";
?"          Employee(bin)         Model                Data";;
?(L_cof|maxc(L_LD[.,1]+1))~L_pmfe~pmfe_dat;
?;
stat_e = L_pmfe-pmfe_dat;
?"    RMSE ";;sqrt(meanc(stat_e^2))*100;
?;
?"    ------------ Employment ------------";
?"          Employee(bin)         Model                Data";;
?(L_cof|maxc(L_LD[.,1]+1))~L_pmfl~pmfl_dat;
?;
stat_l = L_pmfl-pmfl_dat;
?"    RMSE ";;sqrt(meanc(stat_l^2))*100;
?;
?"    ------------ Export Participation rate ------------";
?"          Employee(bin)         Model                Data";;
?(L_cofx|maxc(L_LD[.,1]+1))~L_pmfx~pmfx_dat;
?;
stat_x = pmfx_dat-L_pmfx;
?"    RMSE ";;sqrt(meanc(stat_x^2))*100;
?;
?;
?"    ------------ Establishment+Employment ------------";
?"    RMSE ";;sqrt(meanc((stat_e|stat_l)^2))*100;
?;
?"          sde                 RMSE  ";
?sde;;sqrt(meanc((stat_e|stat_l)^2))*100;
?;
?;

@---- Normalizing Distribution  N=1 @

DT  = sumc(DT0);
DT0  = DT0/DT;
D_E  = D_E;
n_E = sumc(D_E)/sumc(DT);
DT = sumc(DT0);

?" @========================================================================@";
?" @=============================  Initial SS ==============================@";
?" @========================================================================@";
?;
ta  = ta0;   @ initial tariff @
tiL = ( 1 + ta^(-thA)*xiL^(1-thA) ); @ multiplier for exporters @
tiH = ( 1 + ta^(-thA)*xiH^(1-thA) ); @ multiplier for exporters @

R     = 1/bet - 1 + del;   @ Rental rate of capital @

IntT  = exp(zs)'DT0;      @ Integration for non-exporters goods @

S = ( 1 + ta^(1-thA)*xiH^(1-thA) )/( 1 + ta^(-thA)*xiH^(1-thA) ); 
alpm = (1 - 1/2.8)*th/(th-1)*S;   @ matching Gross-VA = 2.8 @
alpm = 0.81008870;  @ benchmark parameter @
clear N_TE, Y, MCN, PT, MCT, ti2, f_0n, f_1n, f_Tn, Lp, V0i, VLi, VHi, EXY, K_T, L_T, D; 

@ ---- Initial values for SS ---- @
K   = 0.5;
f_E = 6.04225614;
NT = 1;
C  = 0.21880511;
W  = 0.14808886;

Xss0=ln(K|f_E|alp|C|W);

Xss0 = 
    -2.88742538|
     1.79877748|
    -2.48512198|
    -1.51957387|
    -1.90994281;

convtol=di; prntit=0;
vSS0  = zeros(rows(Xss0),1);
Xss1 = nlsys(&ss0,Xss0,jc0,convtol,prntit,prntout);
format /rdn 15,8;
?xss1;
?;

gam = W*C^(-sig);

lambda = 1/( 1 + ta^(1-thA)*xiH^(1-thA) );  @ domestic expenditure share @
IMD = ta^(1-thA)*xiH^(1-thA); @ imported/domestic @

lambdas = lambda; @ stacking @
IMDs = IMD;      @ stacking @

@======  Resolving normalization =====@

ti2 = 1/th/( (NT*IntT)^((1-thA)/(1-th)) + ta^(1-thA)*xiL^(1-thA)*(NT*IntT)^((1-thA)/(1-th)) )*S*Y/( S-alpm*(th-1)/th )*(NT*IntT)^((th-thA)/(1-th));

OP  = 1; @ Output Premium @
PP  = 0; @ Productivity premium @

format /rdn 15,8;
?;
?"    beta";;bet;;"  sigma";;sig;;" gamma";;gam;;"  theta";;th;;"  thetaA";;thA;
?"    alpm";;alpm;;" alpha";;alp;;"  delta";;del;
?"    f_T";;f_T;;"  f_0";;f_0;;"   f_1";;f_1;;"   f_E";;f_E;
?"    xiL";;xiL;;"   xiH";;xiH;;"   rhoH";;rhoH;;"   rhoL";;rhoL;;"  ta";;ta;
?"    sde";;sde;;"   rho";;rho;;"   lamD";;lamD;;"   muE";;muE;;"  nd0";;nd0;
?;
?;
format /rdn 15,8;
?"     tariff_rate    xiH            xiL             C              L              TR             LP             n_0            n_1            n_x";;
?"              NT           N_TE          IntX           Tradable_V     Effective_V    K              Y               W             OP";;
?"             PP             z0             zH             zL             lambda         IMD";
?ta~xiH~xiL~C~L~EXY~LP~1~1~1~NT~N_TE~(NT*IntT)~(2*NT)~(NT*IntT)~K~Y~W~OP~PP~1~1~1~lambda~IMD;
?;


?" @============================================================@";
?" @=============== Initial Steady State (Again) ===============@";
?" @============================================================@";
?;
ta  = ta0;
tiL = ( 1 + ta^(-thA)*xiL^(1-thA) ); @ multiplier for exporters @
tiH = ( 1 + ta^(-thA)*xiH^(1-thA) ); @ multiplier for exporters @

convtol=di; prntit=0;  
format /rdn 15,8;
iter2 = 1; do until iter2>10;

   DT0_old = DT0;
   Kold = K;
   Cold = C;
   Wold = W;
   NTold = NT;
   
   Xss0=ln(K|NT|C|W|L);
   vSS1  = zeros(rows(Xss0),1);
   Xss1 = nlsys(&SS1,Xss0,jc0,convtol,prntit,prntout);

   IntT  = exp(zs)'DT0;    @ Integration for domestic tradable goods @
   
   tol1 = maxc(abs(DT0-DT0_old));
   tol4 = maxc(abs((K|NT|C|W)-(Kold|NTold|Cold|Wold)));
   iter2 = 100*(maxc(tol1|tol4).<di);

   OP  = 1; @ Output Premium @
   PP  = 1; @ Productivity premium @

endo; @ iteration for iter2 @

lambda = 1/( 1 + ta^(1-thA)*xiH^(1-thA) );  @ domestic expenditure share @
IMD = ta^(1-thA)*xiH^(1-thA); @ imported/domestic @

lambdas = lambda; @ stacking @
IMDs = IMD;      @ stacking @


format /rdn 15,8;
?"     tariff_rate    xiH            xiL             C              L              TR             LP             n_0            n_1            n_x";;
?"              NT           N_TE          IntX           Tradable_V     Effective_V    K              Y               W             OP";;
?"             PP             z0             zH             zL             lambda         IMD";
?ta~xiH~xiL~C~L~EXY~LP~1~1~1~NT~N_TE~(NT*IntT)~(NT+1*NT)~(NT*IntT)~K~Y~W~OP~PP~1~1~1~lambda~IMD;
?;
C0ss = C;
L0ss = L;

SSout = ta~xiH~xiL~C~L~EXY~LP~1~1~1~NT~N_TE~(NT*IntT)~(NT+1*NT)~(NT*IntT)~K~Y~W~OP~PP~1~1~1~lambda~IMD;
Q = 1;
Bnd = 0;

@ ====  Saving values of key variables ====@
vec0_h  = C|L|W|N_TE|K|R|lambda|1;
vec0_f  = C|L|W|N_TE|K|R|Q|Bnd|lambda|1;
Dist0V0_h = NT*DT0;
Dist0V0_f = NT*DT0;
V0iV0_h  = V0i;
V0iV0_f  = V0i;
EX =EXY*Y;

@ ====  Saving values of key variables ====@
vec0  = C|L|W|N_TE|K|R;
Dist0V0 = NT*DT0;
V0iV0  = V0i;  

Addat0 = C~C~L~L~LP~LP~1~1~1~1~1~1~NT~NT~N_TE~N_TE~(NT*IntT)~(NT*IntT)
         ~(Nt*IntT)~(Nt*IntT)~(Nt*IntT)~(Nt*IntT)~(NT+NT)~(NT+NT)
         ~K~K~Y~Y~W~W~(del*K)~(del*K)~Bnd~Q~EX~EX~lambda~IMD;

?" @============================================================@";
?" @=============== New Steady State (Unilateral)     ==========@";
?" @============================================================@";
?;
ta_h  = ta1; @ home imposes, foreign exporters face @
ta_f  = ta0; @ foreign imposes, home exporters face @

ta_h  = ta1; @ home imposes, foreign exporters face @
ta_f  = ta1; @ foreign imposes, home exporters face @


ta_h  = ta1; @ home imposes, foreign exporters face @
ta_f  = ta0; @ foreign imposes, home exporters face @


B0ss = 0.013460609;  @ Final B @
B0ss = 0.0036278404216867500;  @ Final B @
/*
B0ss = 0;  @ Final B @
*/

clear K_h, K_f, NT_h, NT_f, C_h, C_f, W_h, W_f, L_h, L_f, Q, X_h, X_f, D_h, D_f, N_TE_h, N_TE_f,
      MCN_h, MCN_f, MCT_h, MCT_f, GO_h, GO_f, ti20_h, ti2H_h, ti2L_h, ti20_f, ti2H_f, ti2L_f, Lp_h, Lp_f,
      V0i_h, VHi_h, VLi_h, V0i_f, VHi_f, VLi_f, EV0_h, EVH_h, EVL_h, EV0_f, EVH_f, EVL_f, 
      EV0f_h, EVHf_h, EVLf_h, EV0f_f, EVHf_f, EVLf_f, EX, IM;

@--- Home variables ---@
DT0_h = DT0;
K_h = K;
C_h = C;
W_h = W;
NT_h = NT;
L_h = L0ss;
@--- foreign variables ---@
DT0_f = DT0;
K_f = K;
C_f = C;
W_f = W;
NT_f = NT;
L_f = L0ss;

Q = 1;



convtol=di; prntit=0;  
format /rdn 15,8;
iter2 = 1; do until iter2>10;

   DT0_old_h = DT0_h;
   K_old_h = K_h;
   C_old_h = C_h;
   W_old_h = W_h;
   NT_old_h = NT_h;

   DT0_old_f = DT0_f;
   K_old_f = K_f;
   C_old_f = C_f;
   W_old_f = W_f;
   NT_old_f = NT_f;
   
   Q_old = Q;

   IntT_h  = exp(zs)'DT0_h;      @ Integration for domestic tradable goods @
   IntT_f  = exp(zs)'DT0_f;      @ Integration for domestic tradable goods @

   Xss0=ln(K_h|K_f|NT_h|NT_f|C_h|C_f|W_h|W_f|L_h|L_f|Q);
   vSS1  = zeros(rows(Xss0),1);
   prntit = 0;
   Xss1 = nlsys(&SS_Uni,Xss0,jc0,convtol,prntit,prntout);


   tol1 = maxc(abs((DT0_h|DT0_f)-(DT0_old_h|DT0_old_f)));

   tol4_h = maxc(abs((K_h|NT_h|C_h|W_h)-(K_old_h|NT_old_h|C_old_h|W_old_h)));
   tol4_f = maxc(abs((K_f|NT_f|C_f|W_f)-(K_old_f|NT_old_f|C_old_f|W_old_f)));
   tol4_q = maxc(abs(Q-Q_old));
   iter2 = 100*(maxc(tol1|tol4_h|tol4_f|tol4_q).<di);
   ?(tol1|tol4_h|tol4_f|tol4_q)';
   

endo; @ iteration for iter2 @

Y_h = C_h+del*K_h;
Y_f = C_f+del*K_f;

R_h = R;
R_f = R;

EXY = EX/Y_h;

lambda = (D_h-(ta_h*IM))/D_h;
IMD = (ta_h*IM)/(D_h-(ta_h*IM));

lambdaf = (D_f-(ta_f*EX/Q))/D_f;
IMDf = (ta_f*EX/Q)/(D_f-(ta_f*EX/Q));

QUChUCf = Q*(C_h/C_f)^(-sig);

save DT0_h, K_h, C_h, W_h, NT_h, L_h, 
     DT0_f, C_f, W_f, NT_f, L_f, Q;

format /rdn 15,8;
?"     xiH xiL";;?xiH~xiL;
?"     ta_h           C_h            L_h            Lp_h           n_0_h          n_1_h          n_x_h          NT_h           N_TE_h         IntX_h         Tradable_V_h   Effective_V_h  K_h            GO_h           W_h";
?ta_h~C_h~L_h~Lp_h~1~1~1~NT_h~N_TE_h~(NT_h*(IntT_h))~(NT_h+1*NT_f)~(NT_h*IntT_h)~K_h~GO_h~W_h;
?"     ta_f           C_f            L_f            Lp_f           n_0_f          n_1_f          n_x_f          NT_f           N_TE_f         IntX_f         Tradable_V_f   Effective_V_f  K_f            GO_f           W_f";
?ta_f~C_f~L_f~Lp_f~1~1~1~NT_f~N_TE_f~(NT_f*(IntT_f))~(NT_f+1*NT_f)~(NT_f*IntT_f)~K_f~GO_f~W_f;
?;


@ ====  Saving values of key variables ====@
vec1_h  = C_h|L_h|W_h|N_TE_h|K_h|R_h|lambda|1;
vec1_f  = C_f|L_f|W_f|N_TE_f|K_f|R_f|Q|Bnd|lambdaf|1;
Dist0V1_h = NT_h*DT0_h;
Dist0V1_f = NT_f*DT0_f;
V0iV1_h  = V0i_h;
V0iV1_f  = V0i_f;


Addat1 = C_h~C_f~L_h~L_f~LP_h~LP_f~1~1~1~1~1~1~NT_h~NT_f~N_TE_h~N_TE_f~(NT_h*IntT_h)~(NT_f*IntT_f)
         ~(NT_h*IntT_h)~(NT_f*IntT_f)~(Nt_h*IntT_h)~(Nt_f*IntT_f)~(NT_h+1*NT_f)~(NT_f+1*NT_h)
         ~K_h~K_f~Y_h~Y_f~W_h~W_f~(del*K_h)~(del*K_f)~Bnd~Q~EX~EX~lambda~IMD;

@ =================================================== @
@ ==========  Iteration for Transitions ============= @
@ =================================================== @

clear EV0t1, EVHt1, EVLt1, DV0t1, DVHt1, DVLt1, z0t1new, zHt1new, zLt1new, frac0t1, fracHt1, fracLt1, idx0t1, idxHt1, idxLt1, ms0t1, msHt1, msLt1;
clear EV0ft1, EVHft1, EVLft1, V0it1, VHit1, VLit1, D1, D2, D3, R1, R2, R3, K0, K1, K2, K3,
      z0t1new, frac0t1, idx0t1, ms0t1, zHt1new, fracHt1, idxHt1, msHt1, zLt1new, fracLt1, idxLt1, msLt1, 
      zp0t1new, fracp0t1, idxp0t1, msp0t1, zpHt1new, fracpHt1, idxpHt1, mspHt1, zpLt1new, fracpLt1, idxpLt1, mspLt1, m0t1, mHt1, mLt1; 
clear msp0, mspH, mspL, ms0, msH, msL, D00, D01, DH0, DH1, DL0, DL1, 
      D0new, DHnew, DLnew, D0new, DHnew, DLnew, D1new, 
      SD0, SD01, SD10, SD1H, SD1L, n_0new, n_1new, n_Xnew;
clear L1, W1, K1, N_TE1, L2, W2, N_TE2, N_TE0, 
      zp0t0, zpHt0, zpLt0, z0t0, zHt0, zLt0, zp0t1, zpHt1, zpLt1, z0t1, zHt1, zLt1, zp0t2, zpHt2, zpLt2, z0t2, zHt2, zLt2, zp0t3, zpHt3, zpLt3,
      K0, K2, L3, W3, C1, C2, C3, UC1, UC2, UC3, UL1, UL2, UL3, 
      DT0t0, DTHt0, DTLt0, DT1t0, DT00t0, DT01t0, DTH0t0, DTH1t0, DTL0t0, DTL1t0, DT0t1, DTHt1, DTLt1, DT1t1, n_0t1, n_1t1, n_xt1,
      DT00t1, DT01t1, DTH0t1, DTH1t1, DTL0t1, DTL1t1, DT0t2, DTHt2, DTLt2, DT1t2, n_0t2, n_1t2, n_xt2, 
      DT00t2, DT01t2, DTH0t2, DTH1t2, DTL0t2, DTL1t2, DT0t3, DTHt3, DTLt3, DT1t3, n_0t3, n_1t3, n_xt3, 
      IntT1, IntT2, IntT3, IntH1, IntL1, IntH2, IntL2, IntH3, IntL3, NT1, NT2, V0it2, VHit2, VLit2, V0it3, VHit3, VLit3,
      Y1, S1, Lp1, R1, MCN1, PT1, MCT1, EXY1, PPt1, OPt1, Y2, S2, Lp2, R2, MCN2, PT2, MCT2, 
      EV0t2, EVHt2, EVLt2, EV0ft2, EVHft2, EVLft2, msp0t2, mspHt2, mspLt2; 
      
clear C1_h, W1_h, K1_h, R1_h, N_TE1_h, C1_f, W1_f, K1_f, R1_f, N_TE1_f, Q1, B1, 
      C2_h, W2_h, N_TE2_h, C2_f, W2_f, N_TE2_f, z0t0_h, zHt0_h, zLt0_h, z0t0_f, zHt0_f, zLt0_f, 
      z0t1_h, zHt1_h, zLt1_h, z0t1_f, zHt1_f, zLt1_f, z0t2_h, zHt2_h, zLt2_h, z0t2_f, zHt2_f, zLt2_f, 
      N_TE0_h, K0_h, N_TE0_f, K0_f, B0, L1_h, L1_f, L2_h, K2_h, R2_h, L2_f, K2_f, R2_f, Q2, B2,
      C3_h, L3_h, W3_h, R3_h, C3_f, L3_f, W3_f, R3_f, Q3, B3, UC1_h, UC2_h, UC3_h, UC1_f, UC2_f, UC3_f,
      DT0t0_h, DTHt0_h, DTLt0_h, DT1t0_h, DT0t0_f, DTHt0_f, DTLt0_f, DT1t0_f, 
      DT00t0_h, DT01t0_h, DTH0t0_h, DTH1t0_h, DTL0t0_h, DTL1t0_h, DT0t1_h, DTHt1_h, DTLt1_h, DT1t1_h, n_0t1_h, n_1t1_h, n_xt1_h, 
      DT00t1_h, DT01t1_h, DTH0t1_h, DTH1t1_h, DTL0t1_h, DTL1t1_h, DT0t2_h, DTHt2_h, DTLt2_h, DT1t2_h, n_0t2_h, n_1t2_h, n_xt2_h, 
      DT00t2_h, DT01t2_h, DTH0t2_h, DTH1t2_h, DTL0t2_h, DTL1t2_h, DT0t3_h, DTHt3_h, DTLt3_h, DT1t3_h, n_0t3_h, n_1t3_h, n_xt3_h, 
      DT00t0_f, DT01t0_f, DTH0t0_f, DTH1t0_f, DTL0t0_f, DTL1t0_f, DT0t1_f, DTHt1_f, DTLt1_f, DT1t1_f, n_0t1_f, n_1t1_f, n_xt1_f, 
      DT00t1_f, DT01t1_f, DTH0t1_f, DTH1t1_f, DTL0t1_f, DTL1t1_f, DT0t2_f, DTHt2_f, DTLt2_f, DT1t2_f, n_0t2_f, n_1t2_f, n_xt2_f, 
      DT00t2_f, DT01t2_f, DTH0t2_f, DTH1t2_f, DTL0t2_f, DTL1t2_f, DT0t3_f, DTHt3_f, DTLt3_f, DT1t3_f, n_0t3_f, n_1t3_f, n_xt3_f, 
      IntT1_h, IntT2_h, IntT3_h, IntT1_f, IntT2_f, IntT3_f, IntH1_h, IntL1_h, IntH2_h, IntL2_h, IntH1_f, IntL1_f, IntH2_f, IntL2_f,
      NT1_h, NT2_h, NT1_f, NT2_f, V0it2_h, VHit2_h, VLit2_h, V0it2_f, VHit2_f, VLit2_f, V0it3_h, VHit3_h, VLit3_h, V0it3_f, VHit3_f, VLit3_f, 
      X1_h, D1_h, Lp1_h, MCN1_h, MCT1_h, X1_f, D1_f, Lp1_f, MCN1_f, MCT1_f, X2_h, D2_h, Lp2_h, MCN2_h, MCT2_h, X2_f, D2_f, Lp2_f, MCN2_f, MCT2_f,
      EV0t2_h, EVHt2_h, EVLt2_h, EV0ft2_h, EVHft2_h, EVLft2_h, V0it2_h, VHit2_h, VLit2_h, EV0t1_h, EVHt1_h, EVLt1_h, EV0ft1_h, EVHft1_h, EVLft1_h, 
      ti20t_h, ti2Ht_h, ti2Lt_h, V0it1_h, VHit1_h, VLit1_h, 
      EV0t2_f, EVHt2_f, EVLt2_f, EV0ft2_f, EVHft2_f, EVLft2_f, V0it2_f, VHit2_f, VLit2_f, EV0t1_f, EVHt1_f, EVLt1_f, EV0ft1_f, EVHft1_f, EVLft1_f, 
      ti20t_f, ti2Ht_f, ti2Lt_f, V0it1_f, VHit1_f, VLit1_f, GO2_h, GO2_f,
      EX1_h, IM1_h, GO1_h, GO1_f, Y1_h, Y1_f, TB1_h; 
clear lambda0_h,lambda1_h,lambda2_h,gt1_h,gt2_h,gt0_h,lambda0_f,lambda1_f,lambda2_f,gt1_f,gt2_f,gt0_f;


@============  Matrices for Transitions ============@
T = 300+4;       @ # of periods for the transition @
bound = T-2;   @ Set initial guess based on initial and new steady states @
@bound = T-100;@

@------- Matrices for transtion dynamics --------@
Dats1_h = ones(T,1).*vec0_h'; 
Dist0s1_h = ones(T,1).*Dist0V0_h';
V0is1_h = ones(T,1).*V0iV0_h';

Dats1_f = ones(T,1).*vec0_f'; 
Dist0s1_f = ones(T,1).*Dist0V0_f';
V0is1_f = ones(T,1).*V0iV0_f';

Dats1_h[rows(Dats1_h)-bound:rows(Dats1_h),.] = ones(bound+1,1).*vec1_h';      @ C W NTE K R @
Dist0s1_h[rows(Dist0s1_h)-bound:rows(Dist0s1_h),.] = ones(bound+1,1).*Dist0V1_h';
V0is1_h[rows(V0is1_h)-bound:rows(V0is1_h),.] = ones(bound+1,1).*V0iV1_h';

Dats1_f[rows(Dats1_f)-bound:rows(Dats1_f),.] = ones(bound+1,1).*vec1_f';      @ C W NTE K R @
Dist0s1_f[rows(Dist0s1_f)-bound:rows(Dist0s1_f),.] = ones(bound+1,1).*Dist0V1_f';
V0is1_f[rows(V0is1_f)-bound:rows(V0is1_f),.] = ones(bound+1,1).*V0iV1_f';
/*
ii=2;
do until ii>20;
    Dats1_h[ii,5] = vec0_h[5]+(vec1_h[5]- vec0_h[5])*ii/20;      @ C W NTE K R @
    Dats1_f[ii,5] = vec0_f[5]+(vec1_f[5]- vec0_f[5])*ii/20;      @ C W NTE K R @
    ii= ii+1;
endo;
*/
@end;@
/*
load Dats1_h, Dist0s1_h, V0is1_h;
load Dats1_f, Dist0s1_f, V0is1_f;
*/
T=rows(Dats1_h);


Dats2_h  = Dats1_h;
Dist0s2_h =  Dist0s1_h;
V0is2_h   =  V0is1_h;

Dats2_f  = Dats1_f;
Dist0s2_f =  Dist0s1_f;
V0is2_f   =  V0is1_f;

 
count = 1;   @ iteration counting @
wg    = 1;   @ weight for updating @
strt0 = 1;   @ if 0, take N_TE1(idxst0) = 0 @
idxst0 = T-100;  @ period+1 where the N_TE=0 occurs @
flexL = 1; 

dit=1e-5; convtol=1e-6; prntit=0; convtol=1e-8; maxvf=0;

iter = 1; do until iter>5;
   if count>100; wg = 1; endif;
   i=2; do until i>T-4;

      x0=( ln(dats2_h[i,1 3 5])~(dats2_h[i,4])~ln(dats2_f[i,1 3 5])~(dats2_f[i,4])~ln(dats2_f[i,7])~(dats2_f[i,8])
           ~ln(dats2_h[i+1,1 3])~ln(dats2_f[i+1,1 3])~ln(dats2_h[i,8]~dats2_f[i,10]) )';   @ C|L|W|N_TE|K|R @
      vf=zeros(rows(x0),1);
      prntit=0;
      x1=nlsys(&trans_Uni,x0,jc0,convtol,prntit,prntout); 

      dats2_h[i,1:8]   = C1_h~L1_h~W1_h~N_TE1_h~K1_h~R1_h~lambda1_h~gt1_h;
      dats2_f[i,1:10]   = C1_f~L1_f~W1_f~N_TE1_f~K1_f~R1_f~Q1~B1~lambda1_f~gt1_f;

      Dist0s2_h[i,.] = DT0t1_h';    @ avaialble next period @
      Dist0s2_f[i,.] = DT0t1_f';    @ avaialble next period @
      
      V0is2_h[i+1,.] = V0it2_h';    @ value next period @
      V0is2_h[i,.] = V0it1_h';    @ value next period @
            
      V0is2_f[i+1,.] = V0it2_f';    @ value next period @
      V0is2_f[i,.] = V0it1_f';    @ value next period @
      maxvf = maxvf|maxc(vf);
   i=i+1; endo;


   converg_h = maxc( maxc( abs(dats1_h-dats2_h) ) );  @ you can add more variables to the convergence criterion. But, results are pretty much the same @ 
   converg_f = maxc( maxc( abs(dats1_f-dats2_f) ) );
	 converg_vf = maxc( maxc( abs(maxvf) ) );
   converg = maxc(converg_h|converg_f|converg_vf);

   iter = 100*(converg.<(dit/10));
   format /rdn 8,1;
/*
   ?count;;100*(converg~B1~ln(dats2_h[2,1]/C_h~dats2_f[2,1]/C_f~dats2_h[2,4]/N_TE_h~dats2_f[2,4]/N_TE_f~dats2_h[2,5]/K_old_h~dats2_f[2,5]/K_old_h)) ; pause(0.01);
*/
   format /rdn 15,8;
	?count;;converg;

   Dats2_h   =  wg*Dats2_h+(1-wg)*Dats1_h;
   Dist0s2_h =  wg*Dist0s2_h+(1-wg)*Dist0s1_h;
   V0is2_h   =  wg*V0is2_h+(1-wg)*V0is1_h;

   Dats2_f   =  wg*Dats2_f+(1-wg)*Dats1_f;
   Dist0s2_f =  wg*Dist0s2_f+(1-wg)*Dist0s1_f;
   V0is2_f   =  wg*V0is2_f+(1-wg)*V0is1_f;


/*   if count<50;  
      Trt = T-100;
      Dats2_h[Trt:T,.]   =  ones(T-Trt+1,cols(Dats1_h)).*Dats1_h[T,.];
      Dist0s2_h[Trt:T,.] =  ones(T-Trt+1,cols(Dist0s1_h)).*Dist0s1_h[T,.];
      V0is2_h[Trt:T,.]   =  ones(T-Trt+1,cols(V0is1_h)).*V0is1_h[T,.];
      
      Dats2_f[Trt:T,.]   =  ones(T-Trt+1,cols(Dats1_f)).*Dats1_f[T,.];
      Dist0s2_f[Trt:T,.] =  ones(T-Trt+1,cols(Dist0s1_f)).*Dist0s1_f[T,.];
      V0is2_f[Trt:T,.]   =  ones(T-Trt+1,cols(V0is1_f)).*V0is1_f[T,.];
      
   endif;
 */
   /*
   if count<200; 
      Trt = T-50;
      Dats2[Trt:T,3]   =  ones(T-Trt+1,1).*Dats1[T,3];
   endif;
   */
   Dats1_h   =  Dats2_h;
   Dist0s1_h =  Dist0s2_h;
   V0is1_h   =  V0is2_h;
   
   Dats1_f   =  Dats2_f;
   Dist0s1_f =  Dist0s2_f;
   V0is1_f   =  V0is2_f;
   
count = count +1; endo; @ Convergence of iter @

save Dats1_h, Dist0s1_h, V0is1_h;
save Dats1_f, Dist0s1_f, V0is1_f;


@ ==========  Final Computations for Transitions ============= @
Addats = Addat0; maxvf=0;
i=2; do until i>T-4;
   x0=( ln(dats2_h[i,1 3 5])~(dats2_h[i,4])~ln(dats2_f[i,1 3 5])~(dats2_f[i,4])~ln(dats2_f[i,7])~(dats2_f[i,8])
        ~ln(dats2_h[i+1,1 3])~ln(dats2_f[i+1,1 3])~ln(dats2_h[i,8]~dats2_f[i,10]) )';   @ C|L|W|N_TE|K|R @
   vf=zeros(rows(x0),1);
   @x1=nlsys(&trans_Uni,x0,jc0,convtol,prntit,prntout); @
   {vf}=trans_Uni(x0);
   lambdat1 = 1/( 1 + ta^(1-thA)*xiH^(1-thA) );  @ domestic expenditure share @
   IMDt1 = ta^(1-thA)*xiH^(1-thA); @ imported/domestic @
   lambdat1 = (D1_h-(ta_h*IM1_h))/D1_h;  @ domestic expenditure share @
   IMDt1 = (ta_h*IM1_h)/(D1_h-(ta_h*IM1_h)); @ imported/domestic @
   Addats= Addats|
          ( C1_h~C1_f~L1_h~L1_f~LP1_h~LP1_f~1~1~1~1~1~1~NT1_h~NT1_f~N_TE1_h~N_TE1_f~(NT1_h*IntT1_h)~(NT1_f*IntT1_f)
         ~(NT1_h*IntT1_h)~(NT1_f*IntT1_f)~(NT1_h*IntT1_h)~(NT1_f*IntT1_f)~(NT1_h*IntT1_h)~(NT1_f*IntT1_f)
         ~K0_h~K0_f~Y1_h~Y1_f~W1_h~W1_f~(K1_h-(1-del)*K0_h)~(K1_f-(1-del)*K0_f)~B0~Q1~EX1_h~IM1_h~lambdat1~IMDt1 );
   maxvf=maxvf|maxc(vf);      
i=i+1; endo;
Addats = Addats|(ones(rows(dats1_h)-rows(Addats),cols(Addats)).*Addat1);




@==== Compute B1 =====@
B0tmpp=ones(rows(dats1_h),1)*B0ss;
@B1tmpp[1,1] = -0.015088;@
i=T-4; do until i<2;
   x0=( ln(dats2_h[i,1 3 5])~(dats2_h[i,4])~ln(dats2_f[i,1 3 5])~(dats2_f[i,4])~ln(dats2_f[i,7])~(dats2_f[i,8])
        ~ln(dats2_h[i+1,1 3])~ln(dats2_f[i+1,1 3])~ln(dats2_h[i,8]~dats2_f[i,10]) )';   @ C|L|W|N_TE|K|R @
/*       
   x0=( ln(dats2_h[i,1 3 5 6])~(dats2_h[i,4])~ln(dats2_f[i,1 3 5 6])~(dats2_f[i,4])~ln(dats2_f[i,7])~(dats2_f[i,8])
        ~ln(dats2_h[i+1,1 3])~(dats2_h[i+1,4])~ln(dats2_f[i+1,1 3])~(dats2_f[i+1,4]) )';   @ C|L|W|N_TE|K|R @
*/             
   vf=zeros(rows(x0),1);
   @x1=nlsys(&trans_Uni,x0,jc0,convtol,prntit,prntout); @
   {vf}=trans_Uni(x0);
   lambdat1 = (D1_h-(ta_h*IM1_h))/D1_h;  @ domestic expenditure share @
   IMDt1 = (ta_h*IM1_h)/(D1_h-(ta_h*IM1_h)); @ imported/domestic @
   /*
   Addats= Addats|
          ( C1_h~C1_f~L1_h~L1_f~LP1_h~LP1_f~n_0t1_h~n_0t1_f~n_1t1_h~n_1t1_f~n_xt1_h~n_xt1_f~NT1_h~NT1_f~N_TE1_h~N_TE1_f~(NT1_h*IntT1_h)~(NT1_f*IntT1_f)
         ~(NT1_h*(exp(zs)'DT0t1_h))~(NT1_f*(exp(zs)'DT0t1_f))~(NT1_h*IntH1_h)~(NT1_f*IntH1_f)~(NT1_h*IntL1_h)~(NT1_f*IntL1_f)~(NT1_h+n_xt1_f*NT1_f)~(NT1_f+n_xt1_h*NT1_h) 
         ~K0_h~K0_f~Y1_h~Y1_f~W1_h~W1_f~(K1_h-(1-del)*K0_h)~(K1_f-(1-del)*K0_f)~z0t1_h~z0t1_f~zHt1_h~zHt1_f~zLt1_h~zLt1_f~B0~Q1~EX1_h~IM1_h~lambdat1~IMDt1 );
   */
   B0tmpp[i-1] = D1_h + (bet*UC2_h/UC1_h)*B0tmpp[i] - GO1_h - (ta_h-1)*IM1_h;
i=i-1; endo;

save B0tmpp;
?;
?;
?"  BT    B0      QUChUCf";
?B0ss~B0tmpp[1]~QUChUCf;
?;


if sig == 1;
   Util = ln(Addats[.,1 2]);
else;
   Util = Addats[.,1 2]^(1-sig)/(1-sig);
endif;
Wel0 = Util[1,.]/(1-bet);
Wel1 = ( sumc((bet^seqa(0,1,rows(Util)-1)).*Util[2:rows(Util),.]) )';
Wel1 = Wel1 + bet^(rows(Util)-1)*Util[rows(Util),.]/(1-bet);
if sig==1; 
   DWG = (Wel1./Wel0)*(1-bet);
else;
   DWG = ln(Wel1./Wel0)/(1-sig);
endif;
?" @===============================================@";
?"         Dynamic gains (%)    ";;DWG*100;
?" @===============================================@";
?;
?;


output on; format 15,8;
?" Year";;
?" C1_h  C1_f  L1_h  L1_f  LP1_h  LP1_f  n_0t1_h  n_0t1_f  n_1t1_h  n_1t1_f  n_xt1_h  n_xt1_f  NT1_h  NT1_f  N_TE1_h  N_TE1_f  (NT1_h*IntT1_h)  (NT1_f*IntT1_f)";;
?" (NT1_h*(exp(zs)'DT0t1_h))  (NT1_f*(exp(zs)'DT0t1_f))  (NT1_h*IntH1_h)  (NT1_f*IntH1_f)  (NT1_h*IntL1_h)  (NT1_h*IntL1_h) ";;
?" K0_h  K0_f  Y1_h  Y1_f  W1_h  W1_f  (K1_h-(1-del)*K0_h)  (K1_f-(1-del)*K0_f)  B0 Q1 EX1_h  IM1_h  lambdat1  IMDt1 ";;
?" B0_corrected";;
?seqa(0,1,rows(dats1_h))~Addats~B0tmpp;

save Addats;




@=========================== BEGIN PROC TRANS_Uni(X) ======================================================@
/*  Transition Dynamics Computations   */
            
proc trans_Uni(x); @ Today 1 @

@ N_TE1 : Entrants Today @
@ NT1 : active firms today @
@ Distxx0: Firm distribution last period @
/*
     x0=( ln(dats2_h[i,1 3 5 6] )~(dats2_h[i,4])~ln(dats2_f[i,1 3 5 6])~(dats2_f[i,4])~ln(dats2_f[i,7])~(dats2_f[i,8])
              ~ln(dats2_h[i+1,1 3])~(dats2_h[i+1,4])~ln(dats2_f[i+1,1 3])~(dats2_f[i+1,4]) )';   @ C|L|W|N_TE|K|R @
*/

C1_h = exp(x[1]); 
W1_h = exp(x[2]);
K1_h = exp(x[3]); 
N_TE1_h = (x[4]);    @ decision Today, used tomorrow @

C1_f = exp(x[5]); 
W1_f = exp(x[6]);
K1_f = exp(x[7]); 
N_TE1_f = (x[8]);    @ decision Today, used tomorrow @

Q1 = exp(x[9]);
B1   = (x[10]);
/*
C2_h = exp(x[13]); 
W2_h = exp(x[14]); 
N_TE2_h = (x[15]);    @ decision Today, used tomorrow @
C2_f = exp(x[16]); 
W2_f = exp(x[17]); 
N_TE2_f = (x[18]);    @ decision Today, used tomorrow @
*/

C2_h = exp(x[11]); 
W2_h = exp(x[12]); 
C2_f = exp(x[13]); 
W2_f = exp(x[14]); 

gt1_h = exp(x[15]);
gt1_f = exp(x[16]);

gt0_h = dats2_h[i-1,8];
gt0_f = dats2_f[i-1,10];
gt2_h = dats2_h[i+1,8];
gt2_f = dats2_f[i+1,10];

lambda0_h = dats2_h[i-1,7];
lambda0_f = dats2_f[i-1,9];

N_TE2_h = dats2_h[i+1,4];
N_TE2_f = dats2_f[i+1,4];

N_TE0_h = dats2_h[i-1,4];              @ Yesterday @
K0_h    = dats2_h[i-1,5];

N_TE0_f = dats2_f[i-1,4];              @ Yesterday @
K0_f    = dats2_f[i-1,5];

B0      = dats2_f[i-1,8];


@N_TE2 = dats2[i+1,4]; @
@N_TE1=maxc(0|N_TE1);@
@N_TE2=maxc(0|N_TE2);@


L1_h = dats2_h[i,2];
@R1_h = dats2_h[i,6];@

L1_f = dats2_f[i,2];
@R1_f = dats2_f[i,6];@

L2_h = dats2_h[i+1,2];
K2_h = dats2_h[i+1,5];
@R2_h = dats2_h[i+1,6];@

L2_f = dats2_f[i+1,2];
K2_f = dats2_f[i+1,5];
@R2_f = dats2_f[i+1,6];@

Q2   = dats2_f[i+1,7];
B2   = dats2_f[i+1,8];

C3_h = dats2_h[i+2,1];
L3_h = dats2_h[i+2,2];
W3_h = dats2_h[i+2,3];
R3_h = dats2_h[i+2,6];

C3_f = dats2_f[i+2,1];
L3_f = dats2_f[i+2,2];
W3_f = dats2_f[i+2,3];
R3_f = dats2_f[i+2,6];

Q3   = dats2_f[i+2,7];
B3   = dats2_f[i+2,8];

/*
W1 = gam*C1^sig;
W2 = gam*C2^sig;
*/

UC1_h = C1_h^(-sig);
UC2_h = C2_h^(-sig);
UC3_h = C3_h^(-sig);

UC1_f = C1_f^(-sig);
UC2_f = C2_f^(-sig);
UC3_f = C3_f^(-sig);

DT0t0_h = Dist0s2_h[i-1,.]'; @ Yesterday @
DT0t0_f = Dist0s2_f[i-1,.]'; @ Yesterday @

DT0t1_h = P'( n_S(zs).*DT0t0_h ) + D_E*N_TE0_h; 
DT0t2_h = P'( n_S(zs).*DT0t1_h ) + D_E*N_TE1_h; 
DT0t3_h = P'( n_S(zs).*DT0t2_h ) + D_E*N_TE2_h; 

DT0t1_f = P'( n_S(zs).*DT0t0_f ) + D_E*N_TE0_f; 
DT0t2_f = P'( n_S(zs).*DT0t1_f ) + D_E*N_TE1_f; 
DT0t3_f = P'( n_S(zs).*DT0t2_f ) + D_E*N_TE2_f; 


IntT1_h = exp(zs)'(DT0t1_h);
IntT1_f = exp(zs)'(DT0t1_f);

IntT2_h = exp(zs)'(DT0t2_h);
IntT2_f = exp(zs)'(DT0t2_f);

IntT3_h = exp(zs)'(DT0t3_h);
IntT3_f = exp(zs)'(DT0t3_f);

NT1_h  = sumc(DT0t1_h);
NT2_h  = sumc(DT0t2_h);

NT1_f  = sumc(DT0t1_f);
NT2_f  = sumc(DT0t2_f);

V0it2_h = V0is2_h[i+1,.]';
V0it2_f = V0is2_f[i+1,.]';

V0it3_h = V0is2_h[i+2,.]';
V0it3_f = V0is2_f[i+2,.]';

@W1 = ( th/(th-1)*(1/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )^(1/(1-th)) )^(-1/(1-alpm));@

Lp1_h = L1_h - f_E*N_TE1_h;
Lp1_f = L1_f - f_E*N_TE1_f;

R1_h   = alp/(1-alp)*W1_h*Lp1_h/K0_h;
R1_f   = alp/(1-alp)*W1_f*Lp1_f/K0_f;

X1_h = alpm/(1-alpm)/alp*R1_h*K0_h;
D1_h  = C1_h + K1_h - (1-del)*K0_h + X1_h @+1000*(K1_h-K0_h)^2@;

MCN1_h = (R1_h/alp)^(alp)*(W1_h/(1-alp))^(1-alp);
MCT1_h = (alpm)^(-alpm)*(MCN1_h/(1-alpm))^(1-alpm);

X1_f = alpm/(1-alpm)/alp*R1_f*K0_f;
D1_f  = C1_f + K1_f - (1-del)*K0_f + X1_f @+1000*(K1_f-K0_f)^2@;

MCN1_f = (R1_f/alp)^(alp)*(W1_f/(1-alp))^(1-alp);
MCT1_f = (alpm)^(-alpm)*(MCN1_f/(1-alpm))^(1-alpm);

/*
EXY1 = ta^(-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 )/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1/Y1;
PPt1  = (zs'DT1t1)/sumc(DT1t1) - (zs'DT0t1)/sumc(DT0t1);
OPt1  = ( ( 1+ta^(-th)*xiH^(1-th) )*( exp(zs)'DTHt1 ) + ( 1+ta^(-th)*xiL^(1-th) )*( exp(zs)'DTLt1 ) )
         /( exp(zs)'DT0t1 )*sumc(DT0t1)/sumc(DT1t1);
*/
@-------  t+2 ------@

@W2 = ( th/(th-1)*(1/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )^(1/(1-th)) )^(-1/(1-alpm));@


Lp2_h = L2_h - f_E*N_TE2_h;
Lp2_f = L2_f - f_E*N_TE2_f;

R2_h   = alp/(1-alp)*W2_h*Lp2_h/K1_h;
R2_f   = alp/(1-alp)*W2_f*Lp2_f/K1_f;

X2_h = alpm/(1-alpm)/alp*R2_h*K1_h;
D2_h  = C2_h + K2_h - (1-del)*K1_h + X2_h @+1000*(K2_h-K1_h)^2@;

MCN2_h = (R2_h/alp)^(alp)*(W2_h/(1-alp))^(1-alp);
MCT2_h = (alpm)^(-alpm)*(MCN2_h/(1-alpm))^(1-alpm);

X2_f = alpm/(1-alpm)/alp*R2_f*K1_f;
D2_f  = C2_f + K2_f - (1-del)*K1_f + X2_f @+1000*(K2_f-K1_f)^2@;

MCN2_f = (R2_f/alp)^(alp)*(W2_f/(1-alp))^(1-alp);
MCT2_f = (alpm)^(-alpm)*(MCN2_f/(1-alpm))^(1-alpm);

@--- home ---@
EV0t2_h = bet*UC3_h/UC2_h*n_S(zs).*(P*V0it3_h);  @ discounted expected value when m=0 row(z_today), col=1 @
V0it2_h = 1/th*(th*MCT2_h/(th-1))^(1-thA)*( D2_h*IntT2_h^((th-thA)/(1-th)) + gt2_f*ta_f^(-thA)*xiH^(1-thA)*Q2^thA*D2_f*IntT2_h^((th-thA)/(1-th)) )*exp(zs) + EV0t2_h;

EV0t1_h = bet*UC2_h/UC1_h*n_S(zs).*(P*V0it2_h);  @ discounted expected value when m=0 row(z_today), col=1 @
ti20t_h = 1/th*(th*MCT1_h/(th-1))^(1-thA)*( D1_h*IntT1_f^((th-thA)/(1-th)) + gt1_f*ta_f^(-thA)*xiH^(1-thA)*Q1^thA*D1_f*IntT1_f^((th-thA)/(1-th)) );
V0it1_h = ti20t_h*exp(zs) + EV0t1_h;

@--- Foreign ---@
EV0t2_f = bet*UC3_f/UC2_f*n_S(zs).*(P*V0it3_f);  @ discounted expected value when m=0 row(z_today), col=1 @
V0it2_f = 1/th*(th*MCT2_f/(th-1))^(1-thA)*( D2_f*IntT2_f^((th-thA)/(1-th)) + gt2_h*ta_h^(-thA)*xiH^(1-thA)*Q2^(-thA)*D2_h*IntT2_f^((th-thA)/(1-th)) )*exp(zs) + EV0t2_f;

EV0t1_f = bet*UC2_f/UC1_f*n_S(zs).*(P*V0it2_f);  @ discounted expected value when m=0 row(z_today), col=1 @
ti20t_f = 1/th*(th*MCT1_f/(th-1))^(1-thA)*( D1_f*IntT1_f^((th-thA)/(1-th)) + gt1_h*ta_h^(-thA)*xiH^(1-thA)*Q1^(-thA)*D1_h*IntT1_f^((th-thA)/(1-th)) );
V0it1_f = ti20t_f*exp(zs) + EV0t1_f;


EX1_h = gt1_f*ta_f^(-thA)*Q1^thA*(th*MCT1_h/(th-1))^(1-thA)*D1_f*xiH^(1-thA)*IntT1_h^((1-thA)/(1-th));
IM1_h = gt1_h*ta_h^(-thA)*(th*MCT1_f*Q1/(th-1))^(1-thA)*D1_h*xiH^(1-thA)*IntT1_f^((1-thA)/(1-th));
GO1_h = (th*MCT1_h/(th-1))^(1-thA)*( D1_h*IntT1_h^((1-thA)/(1-th)) + gt1_f*ta_f^(-thA)*Q1^thA*D1_f*xiH^(1-thA)*IntT1_h^((1-thA)/(1-th)) );
GO1_f = (th*MCT1_f/(th-1))^(1-thA)*( D1_f*IntT1_f^((1-thA)/(1-th)) + gt1_h*ta_h^(-thA)*Q1^(-thA)*D1_h*xiH^(1-thA)*IntT1_f^((1-thA)/(1-th)) );
Y1_h  = C1_h + K1_h - (1-del)*K0_h + EX1_h - IM1_h;
Y1_f  = C1_f + K1_f - (1-del)*K0_f + IM1_h/Q1 - EX1_h/Q1;
TB1_h = (EX1_h-IM1_h)/Y1_h;

GO2_h = (th*MCT2_h/(th-1))^(1-thA)*( D2_h*IntT2_h^((1-thA)/(1-th)) + gt2_f*ta_f^(-thA)*Q2^thA*D2_f*xiH^(1-thA)*IntT2_h^((1-thA)/(1-th)) );
GO2_f = (th*MCT2_f/(th-1))^(1-thA)*( D2_f*IntT2_f^((1-thA)/(1-th)) + gt2_h*ta_h^(-thA)*Q2^(-thA)*D2_h*xiH^(1-thA)*IntT2_f^((1-thA)/(1-th)) );


lambda1_h = (D1_h-(ta_h*IM1_h))/D1_h;
lambda1_f = (D1_f-(ta_f*EX1_h/Q1))/D1_f;

/*
vf[1] = bet*UC2_h/UC1_h*(V0it2_h'D_E) - W1_h*f_E*exp(10*(N_TE1_h/N_TE0_h-1));

vf[2] = bet*UC2_f/UC1_f*(V0it2_f'D_E) - W1_f*f_E*exp(10*(N_TE1_f/N_TE0_f-1));
*/
vf[1] = bet*UC2_h/UC1_h*(V0it2_h'D_E) - W1_h*f_E;

vf[2] = bet*UC2_f/UC1_f*(V0it2_f'D_E) - W1_f*f_E;

if (i==idxst0).and (strt0==0); 
   vf[1] = N_TE1_h;
   vf[2] = N_TE1_f;
endif;



vf[3] = alp*(1-alpm)*(th-1)/th*GO1_h - R1_h*K0_h;

vf[4] = alp*(1-alpm)*(th-1)/th*GO1_f - R1_f*K0_f;

vf[5] = (th*MCT1_h/(th-1))^(1-thA)*IntT1_h^((1-thA)/(1-th)) + gt1_h*ta_h^(1-thA)*(th*MCT1_f*Q1/(th-1))^(1-thA)*xiH^(1-thA)*IntT1_f^((1-thA)/(1-th)) - 1;

vf[6] = (th*MCT1_f/(th-1))^(1-thA)*IntT1_f^((1-thA)/(1-th)) + gt1_f*ta_f^(1-thA)*(th*MCT1_h/Q1/(th-1))^(1-thA)*xiH^(1-thA)*IntT1_h^((1-thA)/(1-th)) - 1;

vf[7] = (th*MCT2_h/(th-1))^(1-thA)*IntT2_h^((1-thA)/(1-th)) + gt2_h*ta_h^(1-thA)*(th*MCT2_f*Q2/(th-1))^(1-thA)*xiH^(1-thA)*IntT2_f^((1-thA)/(1-th))  - 1;

vf[8] = (th*MCT2_f/(th-1))^(1-thA)*IntT2_f^((1-thA)/(1-th)) + gt2_f*ta_f^(1-thA)*(th*MCT2_h/Q2/(th-1))^(1-thA)*xiH^(1-thA)*IntT2_h^((1-thA)/(1-th)) - 1;


vf[9] = bet*UC2_h/UC1_h*(R2_h + 1 - del) - 1;

vf[10] = bet*UC2_f/UC1_f*(R2_f + 1 - del) - 1;
/*
vf[15] = D1_h + (bet*UC2_h/UC1_h - 0*B1)*B1 - ( (ta_h-1)*IM1_h + GO1_h + B0 );

vf[16] = D1_f - (bet*UC2_h/UC1_h - 0*B1)*B1/Q1 - ( (ta_f-1)*EX1_h/Q1 + GO1_f - B0/Q1);
*/
vf[11] = B1;

@vf[15] = D1_h + (bet*UC2_h/UC1_h)*B1 - ( (ta_h-1)*IM1_h + GO1_h + B0 );@

vf[12] = Q1 - UC1_f/UC1_h*QUChUCf;

/*
vf[15] = bet*UC2_h/UC1_h - 0*B1 - ( bet*UC2_f/UC1_f*Q1/Q2 + 0*B1*Q1);

vf[16] = D1_f - (bet*UC2_h/UC1_h - 0*B1)*B1/Q1 - ( (ta_f-1)*EX1_h/Q1 + GO1_f - B0/Q1);
*/
/*
vf[17] = bet*UC3_h/UC2_h*(V0it3_h'D_E) - W2_h*f_E;

vf[18] = bet*UC3_f/UC2_f*(V0it3_f'D_E) - W2_f*f_E;
*/

vf[13] = gt0_h^rhog*(lambda1_h/lambda0_h)^(fi*(1-rhog)) - gt1_h;

vf[14] = gt0_f^rhog*(lambda1_f/lambda0_f)^(fi*(1-rhog)) - gt1_f;

vf[15] = alp*(1-alpm)*(th-1)/th*GO2_h - R2_h*K1_h;

vf[16] = alp*(1-alpm)*(th-1)/th*GO2_f - R2_f*K1_f;

retp(vf);
endp;
@=========================== END PROC TRANS_Uni(X) ======================================================@





































@=========================== BEGIN PROC SS_Uni(x) ======================================================@
/*
   Compute the new Steady State
*/

proc SS_Uni(x);

local tol, tol_h, tol_f, i, iter, V0i_new_h, V0i_new_f;

K_h   = exp(x[1]);  @ capital @
K_f   = exp(x[2]);  @ capital @
NT_h  = exp(x[3]);  @ mass of tradable good producers @
NT_f  = exp(x[4]);  @ mass of tradable good producers @
C_h   = exp(x[5]);  @ consumption @
C_f   = exp(x[6]);  @ consumption @
W_h   = exp(x[7]);  @ Wage rate @
W_f   = exp(x[8]);  @ Wage rate @
L_h   = exp(x[9]);  @ Wage rate @
L_f   = exp(x[10]);  @ Wage rate @
Q     = exp(x[11]);  @ RER @

X_h = alpm/(1-alpm)/alp*R*K_h;
X_f = alpm/(1-alpm)/alp*R*K_f;

D_h = C_h + del*K_h + X_h;
D_f = C_f + del*K_f + X_f;

N_TE_h = NT_h*n_E;    @ mass of tradable good entrants @
N_TE_f = NT_f*n_E;    @ mass of tradable good entrants @

MCN_h  = (R/alp)^(alp)*(W_h/(1-alp))^(1-alp);
MCN_f  = (R/alp)^(alp)*(W_f/(1-alp))^(1-alp);
MCT_h  = (alpm)^(-alpm)*(MCN_h/(1-alpm))^(1-alpm);
MCT_f  = (alpm)^(-alpm)*(MCN_f/(1-alpm))^(1-alpm);

GO_h   = (th*MCT_h/(th-1))^(1-thA)*( D_h*(NT_h*IntT_h)^((1-thA)/(1-th)) + D_f*Q^thA*ta_f^(-thA)*xiH^(1-thA)*(NT_h*IntT_h)^((1-thA)/(1-th)) );   @ Gross Output @
GO_f   = (th*MCT_f/(th-1))^(1-thA)*( D_f*(NT_f*IntT_f)^((1-thA)/(1-th)) + D_h*Q^(-thA)*ta_h^(-thA)*xiH^(1-thA)*(NT_f*IntT_f)^((1-thA)/(1-th)) );   @ Gross Output @

ti20_h = 1/th*(th*MCT_h/(th-1))^(1-thA)*( D_h*(NT_h*IntT_h)^((th-thA)/(1-th)) + D_f*Q^thA*ta_f^(-thA)*xiH^(1-thA)*(NT_h*IntT_h)^((th-thA)/(1-th)) );
ti20_f = 1/th*(th*MCT_f/(th-1))^(1-thA)*( D_f*(NT_f*IntT_f)^((th-thA)/(1-th)) + D_h*Q^(-thA)*ta_h^(-thA)*xiH^(1-thA)*(NT_f*IntT_f)^((th-thA)/(1-th)) );

Lp_h   = L - f_E*N_TE_h;  @ Labor in production @
Lp_f   = L - f_E*N_TE_f;  @ Labor in production @

V0i_h = ti20_h*exp(zs)/bet;  @ row (Z), cols (f) current period non-exporter  row(z_today), col(f_today) @
V0i_f = ti20_f*exp(zs)/bet;  @ row (Z), cols (f) current period non-exporter  row(z_today), col(f_today) @

iter=1; do until iter>10;
   EV0_h = bet*n_S(zs).*(P*V0i_h);  @ discounted expected value when m=0 row(z_today), col=1 @
   EV0_f = bet*n_S(zs).*(P*V0i_f);  @ discounted expected value when m=0 row(z_today), col=1 @
   @ expected value after payments decision @
      
   V0i_new_h = ti20_h*exp(zs) + EV0_h;
   V0i_new_f = ti20_f*exp(zs) + EV0_f;

   tol_h = maxc( abs( vec(V0i_h) - vec(V0i_new_h) ) );
   tol_f = maxc( abs( vec(V0i_f) - vec(V0i_new_f) ) );
   tol = tol_h|tol_f;
   iter = 100*(tol.<1e-14);
   
   V0i_h = V0i_new_h;
   V0i_f = V0i_new_f;
endo;

EX = ta_f^(-thA)*q^thA*( th*MCT_h/(th-1) )^(1-thA)*D_f*xiH^(1-thA)*(NT_h*IntT_h)^((1-thA)/(1-th));

IM = ta_h^(-thA)*q^(1-thA)*( th*MCT_f/(th-1) )^(1-thA)*D_h*xiH^(1-thA)*(NT_f*IntT_f)^((1-thA)/(1-th));

vSS1[1] = ( th*MCT_h/(th-1))^(1-thA)*(NT_h*IntT_h)^((1-thA)/(1-th)) 
          + ta_h^(1-thA)*( th*MCT_f*Q/(th-1) )^(1-thA)*xiH^(1-thA)*(NT_f*IntT_f)^((1-thA)/(1-th)) - 1;
          
vSS1[2] = ( th*MCT_f/(th-1))^(1-thA)*(NT_f*IntT_f)^((1-thA)/(1-th))
          + ta_f^(1-thA)*( th*MCT_h/Q/(th-1) )^(1-thA)*xiH^(1-thA)*(NT_h*IntT_h)^((1-thA)/(1-th)) - 1;
          
vSS1[3] = (th-1)/th*alp*(1-alpm)/R*GO_h - K_h;

vSS1[4] = (th-1)/th*alp*(1-alpm)/R*GO_f - K_f;

vSS1[5] = -f_E*W_h + bet*(V0i_h'D_E);

vSS1[6] = -f_E*W_f + bet*(V0i_f'D_E);

vSS1[7] = (1-alp)/alp*R*K_h/W_h - Lp_h;

vSS1[8] = (1-alp)/alp*R*K_f/W_f - Lp_f;

vSS1[9] = L_h - L0ss;  @ for endogenous L @
 
vSS1[10] = L_f - L0ss; @ for endogenous L @ 

vSS1[11] = D_h + (bet-1)*B0ss - GO_h - (ta_h-1)*IM;
/*
vSS1[11] = EX-IM;

vSS1[11] = C_h+del*K_h+X_h - th/(th-1)/(1-alpm)/(1-alp)*W_h*Lp_h - (ta_h-1)*IM;

vSS1[11] = C_h+del*K_h+X_h - GO_h - (ta_h-1)*IM;
*/

retp(vSS1);
endp;
@=========================== END PROC SS_Uni(x) ======================================================@






@=========================== BEGIN PROC SS1(x) ======================================================@
/*
   Compute the new Steady State
*/

proc SS1(x);

local tol, i, iter, V0i_new, VLi_new, VHi_new;

K   = exp(x[1]);  @ capital @
NT  = exp(x[2]);  @ mass of tradable good producers @
C   = exp(x[3]);  @ consumption @
W   = exp(x[4]);  @ Wage rate @
L   = exp(x[5]);  @ Wage rate @

N_TE = NT*n_E;    @ mass of tradable good entrants @

Y    = C + del*K;    @ Absorption @
S    = ( 1 + ta^(1-thA)*xiH^(1-thA) )/( 1 + ta^(-thA)*xiH^(1-thA) );
D    = S*Y/( S-alpm*(th-1)/th );
MCN  = (R/alp)^(alp)*(W/(1-alp))^(1-alp);  
PT   = ( th/(th-1)*(MCN/(1-alpm))^(1-alpm)*alpm^(-alpm)*( (NT*IntT)^((1-thA)/(1-th)) + ta^(1-thA)*xiH^(1-thA)*(NT*IntT)^((1-thA)/(1-th)) )^(1/(1-thA)) )^(1/(1-alpm));
MCT  = (alpm/PT)^(-alpm)*(MCN/(1-alpm))^(1-alpm);

ti2 = 1/th/( (NT*IntT)^((1-thA)/(1-th)) + ta^(1-thA)*xiH^(1-thA)*(NT*IntT)^((1-thA)/(1-th)) )*D*(NT*IntT)^((th-thA)/(1-th));  @ multiplier for profit @

Lp   = L - f_E*N_TE;  @ Labor in production @

V0i = ti2*exp(zs)*tiH/bet;     @ row (Z), cols (f) current period non-exporter  row(z_today), col(f_today) @

iter=1; do until iter>10;
   EV0 = bet*n_S(zs).*(P*V0i);  @ discounted expected value when m=0 row(z_today), col=1 @
   V0i_new = ti2*exp(zs)*tiH + EV0;
   tol = maxc( abs( vec(V0i) - vec(V0i_new) ) );
   iter = 100*(tol.<1e-14);
   
   V0i = V0i_new;
   
endo;

EXY = ta^(-thA)*xiH^(1-thA)/( 1 + ta^(1-thA)*xiH^(1-thA) )*D/Y; @ Export-GDP ratio @

K_T = alp*(1-alpm)*(th-1)/th/R*D/S;
L_T = (1-alp)/alp*R/W*K_T;

vSS1[1] = PT - 1;

vSS1[2] = -f_E*W + bet*(V0i'D_E);

vSS1[3] = K_T - K;

vSS1[4] = W*Lp + R*K + 1/((1-alp)*(1-alpm))/(th-1)*W*L_T + (ta-1)*EXY*Y - Y;
/*
vSS1[5] = gam*C^(sig) - W; 
*/

vSS1[5] = L - L0ss; 

retp(vSS1);
endp;
@=========================== END PROC SS1(x) ======================================================@






@=========================== BEGIN PROC SS0(x) ======================================================@
/*
   Compute the initial Steady State
*/

proc SS0(x);

local tol, i;
K   = exp(x[1]);  @ capital @
f_E = exp(x[2]);  @ entry sunk cost @
alp = exp(x[3]);  @ capital share parameter in production @
C   = exp(x[4]);  @ consumption @
W   = exp(x[5]);  @ Wage rate @

N_TE = n_E;    @ mass of tradable good entrants @

Y    = C + del*K;    @ Absorption @
D    = S*Y/( S-alpm*(th-1)/th );
MCN  = (R/alp)^(alp)*(W/(1-alp))^(1-alp);  
PT   = ( th/(th-1)*(MCN/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT^((1-thA)/(1-th)) + ta^(1-thA)*xiH^(1-thA)*IntT^((1-thA)/(1-th)) )^(1/(1-thA)) )^(1/(1-alpm));
MCT  = (alpm/PT)^(-alpm)*(MCN/(1-alpm))^(1-alpm);

ti2 = 1/th/( IntT^((1-thA)/(1-th)) + ta^(1-thA)*xiH^(1-thA)*IntT^((1-thA)/(1-th)) )*D*IntT^((th-thA)/(1-th));  @ multiplier for profit @

Lp   = L - f_E*N_TE;  @ Labor in production @

V0i = V0*ti2;

EXY = ta^(-thA)*xiH^(1-thA)/( 1 + ta^(1-thA)*xiH^(1-thA) )*D/Y; @ Export-GDP ratio @

K_T = alp*(1-alpm)*(th-1)/th/R*D/S;
L_T = (1-alp)/alp*R/W*K_T;

vSS0[1] = PT - 1;

vSS0[2] = -f_E*W + bet*(V0i'D_E);
/*
vSS0[3] = W*L/Y - (1-alp0);

vSS0[3] = alp - alp0;
*/
vSS0[3] = alp - 0.13247214;

vSS0[4] = K_T - K;

vSS0[5] = W*Lp + R*K + 1/((1-alp)*(1-alpm))/(th-1)*W*L_T + (ta-1)*EXY*Y - Y;

retp(vSS0);
endp;
@=========================== END PROC SS0(x) ======================================================@




























@--------------- BEGIN PROC simul(x) -------------------@
proc(1)= simul(paras);

sde  = paras[1];
rho  = paras[2]; 
nd0  = paras[3];
muE  = paras[4];
xiH  = paras[5];
xiL  = paras[6];
rhoH = paras[7];
rhoL = paras[8];
Prob0= paras[9];
f_0  = paras[10];
f_1  = paras[11];

if rhoLH==1; rhoL = rhoH; endif;

zp0 = cdfni(prob0)*sdz+muE;  @ entrant's production cut off @
zpH = zp0; @ to be calculated @
zpL = zp0; @ to be calculated @
/*
@-------  Find xiL to match year-5 intensity ---@
convtol=di;    prntit=0;
vxiL=ones(1,1);
x1 = nlsys(&findxiL,ln(xiL),jc0,convtol,prntit,prntout);
*/
tiH = ( 1 + ta^(-thA)*xiH^(1-thA) ); @ multiplier for exporters with H @
tiL = ( 1 + ta^(-thA)*xiL^(1-thA) ); @ multiplier for exporters with L @

@-----------------------------------------------------------------@
@------ Computing unconditional and Conditional Distribution -----@
@-----------------------------------------------------------------@
sdz  = sqrt(sde^2/(1-rho^2));            @ Unconditional SD conditional on survival @
nodes  = 200;                            @ # of Nodes for discritization @
inprob = 1e-8;                           @ initial node set up cdfni(m)*sqrt(sde^2/(1-rho^2)) @

y1     = cdfni(inprob)*sde*1.5;          @ lowest value for z @ 
yN     = -cdfni(inprob)*sde*1.5;         @ highest value for z@
ome     = (yN-y1)/(nodes-1);             @ interval @
zs     = seqa(y1,ome,nodes);             @ nodes @
zsL    = zs-ome/2;                       @ min points @

@----- Computing Transition matrix ------@
P     = zeros(nodes,nodes);              @ Transition matrix pjk = Pr(yk|yj) @
j=1; do until j>nodes;
   k=1; do until k>nodes;
      P[j,k] = cdfn( (zs[k]-rho*zs[j]+ome/2)/sde ) - cdfn( (zs[k]-rho*zs[j]-ome/2)/sde );
      if P[j,k]<1e-10; P[j,k]=0; endif;
   k=k+1; endo;
j=j+1; endo;
P = P./(sumc(P'));                       @ Transition Matrix @

@------ Entrant' distribution: mass normalized to 1 -------@
D_E = zeros(nodes,1);
j=1; do until j>nodes;
  D_E[j] = cdfn( (zs[j]+muE+ome/2)/sdz ) - cdfn( (zs[j]+muE-ome/2)/sdz );
j=j+1; endo;
D_E = D_E/(sumc(D_E));

@ Finding the value functions given f_0 and f_1 @
@V0HL = Val0HL(ln(f_0|f_1));@

@--- Initial values: to be corrected ---@
V0 = 1/bet.*exp(zs)*tiH;      @ current period non-exporter   row(z_today) @
iter=1; do until iter>10;
   EV0 = bet*n_S(zs).*(P*V0);  @ discounted expected value when m=0 row(z_today), col=1 @
   V0_new = exp(zs)*tiH + EV0;
   tol = maxc( abs( vec(V0) - vec(V0_new) ) );
   iter = 100*(tol.<1e-10);
   V0 = V0_new;
   @tol;@
endo;

@------ Initial distribution rows(zs) -----@
DT0 = D_E;
iter=1; do until iter>10;
   @---- innovation after survival and productivity shocks----@
   DT0new = P'( n_S(zs).*DT0 ) + D_E; 
   tol = maxc(abs( DT0 - DT0new ) );
   iter = 100*(tol.<1e-14);
   
   DT0 = DT0new;
endo;

@---- 5-year exit ----@
DE0s  = D_E;

iter=1; do until iter>5;
   @---- exporting decisions after cost shocks ----@
   @---- innovation after survival and productivity shocks----@
   DE0new = P'( n_S(zs).*DE0s[.,iter] ); 
   DE0s = DE0s~DE0new;
iter = iter+1; endo;
Exit5 = 1-sumc(DE0s[.,6])/sumc(DE0s[.,1]);

@------ eei ------@
IntT = exp(zs)'DT0;    @ Integration for nontraded goods       @ 
eei  = xiH^(1-thA)*ta^(-thA)/( 1 + xiH^(1-thA)*ta^(-thA) ); @ intensity of all @

@----------  Labor -------------@
L_0 = exp(zs)*tiH;       @ normalized labor @

L_T = L_0'DT0;  @ Total Labor @
Ly0 = L_0'D_E;          @ 0-year labor @

DDT00 = DT0 - (n_S(zs).*DT0); @ shutdown plants of 00 @

Ld0 = L_0'(DDT00);  @ Shutdown plants' labor @

shutdown = sumc(D_E)/sumc(DT0);

@===================================@
@===     EMPLOYMENT DISTRIBUTION ===@
@===================================@
wgtL  =  L1992/E1992*sumc(DT0+DT1)/L_T;

L_0D = (L_0*wgtL)~(DT0/sumc(DT0));

L_cof = 5|10|20|50|100|250|500|1000|2500;

i=1; do until i>rows(L_cof);
   if i==1;
      L_cmfe = sumc(L_0D[.,2].*(L_0D[.,1].<L_cof[i]));  @ Establishment @
      L_cmfl = sumc((L_0D[.,1].*L_0D[.,2]).*(L_0D[.,1].<L_cof[i])); @ Employment @
      L_pmfe = L_cmfe;
      L_pmfl = L_cmfl;
   else;
      L_cmfe = L_cmfe|( sumc(L_0D[.,2].*(L_0D[.,1].<L_cof[i])) );
      L_cmfl = L_cmfl|( sumc((L_0D[.,1].*L_0D[.,2]).*(L_0D[.,1].<L_cof[i])) );
      L_pmfe = L_pmfe|(L_cmfe[i]-L_cmfe[i-1]);
      L_pmfl = L_pmfl|(L_cmfl[i]-L_cmfl[i-1]);
   endif;
i=i+1; endo;
L_cmfe = L_cmfe|(sumc(L_0D[.,2]));
L_pmfe = L_pmfe|(L_cmfe[rows(L_cmfe)]-L_cmfe[rows(L_cmfe)-1]);

L_cmfl = L_cmfl|(L_0D[.,1]'L_0D[.,2]);
L_pmfl = L_pmfl|(L_cmfl[rows(L_cmfl)]-L_cmfl[rows(L_cmfl)-1]);

L_pmfl = L_pmfl/L_cmfl[rows(L_cmfl)];
L_cmfl = L_cmfl/L_cmfl[rows(L_cmfl)];

@============ Export participation rate distribution ==========@

L_cofx = 100|250|500|1000|2500;

L_cmfx = ones(rows(L_cofx)+1,1);
L_pmfx = ones(rows(L_cofx)+1,1);

retp(paras);
endp;
@--------------- END PROC simul(x) -------------------@

@--------------- BEGIN PROC n_S(x) -------------------@
@  Finding shutdown probability given nd0 and lamD    @
@-----------------------------------------------------@
proc n_S(x);
   local nS;
   nS = 1-exp(-lamD*exp(x));  @ probability of survival @
   nS = nS - nd0;     
   nS = maxc((nS')|zeros(1,rows(nS)));
   nS = minc((nS')|ones(1,rows(nS)));
  
retp(nS);
endp;
@--------------- END PROC n_S(x) -------------------@



















@--------------- BEGIN PROC Paraall(x) -------------------@
proc(1)= Paraall(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
lamD = exp(xft01[3]);
rhoH = exp(xft01[4]);
nd0  = exp(xft01[5]);
muE  = exp(xft01[6]);
rho  = 1-exp(xft01[7]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = Exit5 - Exit50;
vfT01[4] = eei - eei0;
vfT01[5] = Ly0/L_T - Ly00;
vfT01[6] = Ld0/L_T - Ld00;

esum = meanc(((pmfe_dat-L_pmfe)/distwgt)^2);
@lsum = sumc(((pmfl_dat-L_pmfl)/distwgt)^2);@

retp((vfT01'vfT01)*ndistwgt+esum@+lsum@);
endp;
@--------------- END PROC Paraall(x) -------------------@

@--------------- BEGIN PROC fT01all1(x) -------------------@
proc(1)= fT01all1(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
lamD = exp(xft01[3]);
rhoH = exp(xft01[4]);
nd0  = exp(xft01[5]);
muE  = exp(xft01[6]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = Exit5 - Exit50;
vfT01[4] = eei - eei0;
vfT01[5] = Ly0/L_T - Ly00;
vfT01[6] = Ld0/L_T - Ld00;

@esum = meanc(((pmfe_dat-L_pmfe)/distwgt)^2);@
@lsum = sumc(((pmfl_dat-L_pmfl)/distwgt)^2);@

retp((vfT01'vfT01*10));
endp;
@--------------- END PROC fT01all1(x) -------------------@



@--------------- BEGIN PROC fT01(x) -------------------@
proc(1)= fT01(xft01);
local esum, lsum;

f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01(x) -------------------@


@--------------- BEGIN PROC fT01rhoHxiH(x) -------------------@
proc(1)= fT01rhoHxiH(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
rhoH = exp(xft01[3]);
xiH  = exp(xft01[4]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

Eintensityall = DTH.*ta^(-thA)*xiH^(1-thA)/( 1 + ta^(-thA)*xiH^(1-thA) ) + DTL.*ta^(-thA)*xiL^(1-thA)/( 1 + ta^(-thA)*xiL^(1-thA) );
Eintensityall = sumc(Eintensityall)/sumc(DTH+DTL);
EEi00 = ta^(-thA)*xiH^(1-thA)/( 1 + ta^(-thA)*xiH^(1-thA) );

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = eei - eei0;
vfT01[4] = EEi00 - Eintensityall*0.5; 

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01rhoH(x) -------------------@


@--------------- BEGIN PROC fT01rhoH(x) -------------------@
proc(1)= fT01rhoH(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
rhoH = exp(xft01[3]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = eei - eei0;

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01rhoH(x) -------------------@


@--------------- BEGIN PROC lamndmu(x) -------------------@
proc(1)= lamndmu(xft01);
lamD = exp(xft01[1]);
nd0  = exp(xft01[2]);
muE  = exp(xft01[3]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = Exit5 - Exit50;
vfT01[2] = Ly0/L_T - Ly00;
vfT01[3] = Ld0/L_T - Ld00;

retp((vfT01'vfT01*10));
endp;
@--------------- END PROC lamndmu(x) -------------------@









