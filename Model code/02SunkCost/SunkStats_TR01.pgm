/***************************************************
   GAUSS Prgram for George Alessandria, Horag Choi, and Kim J. Ruhl (2020) 
   "Trade Adjustment Dynamics and the Welfare Gains from Trade," Working Paper

   BENCHMARK MODEL 
     
   The program is written for GAUSS version 5
     
   The program computes the transition dynamics of the economy.
   The program requires 
      i) non-linear system equations package (nlsys.set and nlproc.arc, Lee Edlefsen  3/29/86) and 
      ii) Optimization application
   For newer versions of these applications, you may need to modify the program where they are applied.
     
   Date: 17 November 2020          
 ***************************************************/
new;cls;
output file = SunkStats_TR01.out reset;

library  optmum, pgraph;
#include nlsys.set;
#include olss.src;
rndseed 123456;

di   = 1e-8;             @ convergence tolerence @
/*===========================================================*
 * Variables for the Solutions of Nonlinear System Equations *
 *===========================================================*/
    convtol=di;          @ convergence tolerance.                  @
    prntit=0;            @ if 1 will print on every iteration @
    prntout=0;           @ if 1, will print final output;
                         NOTE: the solution vector is always
                               assigned to x1, and will be in memory when
                               the program is completed.               @
    fname=&f;            @ change this if the name of the proc
                           containing the functions is not = f     @
    gradname=&grad1;     @ change this tO specify another proc to 
                           compute the Jacobian matrix, if desired.@ 
    jc0=0;               @ change this to specify a KxK matrix to be
                           used as the initial value of the Jacobian,
                           if desired.                             @ 
    fname=&f;
/*===========================================================*/
format /rdn 20,8;

bet  = 0.96;               @ time discount factor @
th   = 5.00;               @ elasticity of substitution b/w varieties @
sig  = 2;                  @ CRRA @
gam  = 0.3;                @ No need here: labor share parameter @

del  = 0.10;               @ capital depreciation rate @

alp0 = 0.34;               @ target 1-labor share of VA @
alp  = 0.218;              @ To be corrected: 1- labor sahre of VA @
alpm = (1 - 1/2.8)*th/(th-1);  @ to be corrected: material share parameter: Matching MFR-output/MFR-VA = 2.8 @

L0ss = 1;                  @ SS Labor supply: Exogenous @
L    = 1;

lamD  = 5.51;               @ To be calibrated:  prob of death slope parameter @
n_x0  = 0.223;              @ exporter ratio @
n_10  = 0.17;               @ Stopper rate @
n_00  = 0.10;               @ To be set: Starter rate @
Exit50= 0.37;               @ 5-year exit rate in the data @
prob0 = 0.20;               @ Entrant's shutdown probability due to fixed cost in production @
Ld00 = 0.023;               @ shutdown plant's labor share @
Ly00 = 0.015;               @ entrant's labor share @

eei0 = 0.133;              @ Export intensity @
eei5 = eei0*1;             @ 5 year exporter's expected intensity @
ta0  = 1.10;               @ Initial gross tariff rate @
ta1  = 1.0;                @ new tariff rate @
ta   = ta0;                @ initial tariff rate @
xi  = ( eei0/(1-eei0)*ta^th )^(1/(1-th));  @ iceberg cost @
xiH  = ( eei0/2/(1-eei0/2)*ta^th )^(1/(1-th));  @ iceberg cost of H set to be 0.5*eei0 @

xiL = 1.1;                 @ to be corrected: to get the average intensity @
rhoH = 0.96976;            @ to be corrected: to get the intensity in 5 years: 1/(1-rho) = E(waiting time) @
rhoL = 1;            @ to be corrected: to get the intensity in 5 years: 1/(1-rho) = E(waiting time) @
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ to be corrected: multiplier for exporters @
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ to be corrected: multiplier for exporters @


TR_bench = 0.22526387;

xi  = ( eei0/(1-eei0)*ta^th )^(1/(1-th));  @ iceberg cost @
xi = xi + 0.011725;  @ ta = 10% @

@ Total employees in MFR: 16948.9*1000 @
@ # of MFR producers: 370912 @
L1992 = 16948.9*1000;
E1992 = 370912;

pmfe_dat =    @ Establishment Data @
0.348044819|
0.178063799|
0.153149534|
0.152720861|
0.075600142|
0.058779441|
0.021021159|
0.008449444|
0.003248749|
0.000922052;
pmfl_dat =     @ employment Data @
0.013334041|
0.025977781|
0.046173543|
0.104383124|
0.116112360|
0.197957414|
0.158763592|
0.125210188|
0.105639827|
0.106448130;

pmfx_dat =  @ export participation rate @
          19.7450|
          40.4419|
          53.5769|
          61.9534|
          72.6595|
          79.2398;
pmfx_dat = pmfx_dat/100;

muE =  0.34084489;       @ entrants' disadvantage @
nd0 =  0.02176593;       @ constant shut-down shock @

f_0 = 2.99979829;        @ normalized startup cost @
f_1 = 1.20521080;        @ normalized continuation cost @

distwgt = 10; @ search weight (1/distwgt) for distribution @
distwgt = 20; @ search weight (1/distwgt) for distribution @
ndistwgt = 10; @ search weight (ndistwgt) for others @

   rhoLH = 0;

   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     1.16940256; f_1  =     1.10597928;
   xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000; @ RMSE           0.50161358 @
   
   sde =     1.31600000; rho =     0.65442341;  muE =     1.34365879;
   lamD=    20.93167832; nd0 =     0.02256872;  f_T =     0.00000000;  f_0 =     1.15626730; f_1  =     1.09521275;
   xiL =     1.17528650; xiH =     1.71823402; rhoH =     0.89040066; rhoL =     1.00000000; @ RMSE           0.50374691 @

   sde =     1.32400000; rho =     0.65442341;  muE =     1.34432421;
   lamD=    21.17754558; nd0 =     0.02258207;  f_T =     0.00000000;  f_0 =     1.18270149; f_1  =     1.11686863;
   xiL =     1.17439721; xiH =     1.71823402; rhoH =     0.89081152; rhoL =     1.00000000; @     RMSE           1.10914937 @

   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     1.16940256; f_1  =     1.10597928;
   xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000; @ RMSE           0.50161358 @

   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     1.16940256; f_1  =     1.10597928;
   xiL =     1.17483838; xiH =     1.71823402; rhoH =     0.89060797; rhoL =     1.00000000; @ RMSE           0.50161358 @




   sde =     1.32000000; rho =     0.65442563;  muE =     1.34393480;
   lamD=    21.05437874; nd0 =     0.02257745;  f_T =     0.00000000;  f_0 =     2.28246072; f_1  =     0.60022105;
   xiL =     1.41920614; xiH =     1.41920614; rhoH =     0.50000000; rhoL =     0.50000000;
   
@ correction for xiH=xiL @

xiH = 1.41920614+0.005711;

   sde =     1.32000000; rho =     0.65442341;  muE =     1.34291214;
   lamD=    21.04284098; nd0 =     0.02258301;  f_T =     0.00000000;  f_0 =     2.24579339; f_1  =     0.59066502;
   xiL =     1.42491250; xiH =     1.42491250; rhoH =     0.50000000; rhoL =     0.50000000;

rhoLH = 1;
rhoH = 0.5; 
rhoL =0.5; 
xi = xiH; 
xiL = xi;
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ to be corrected: multiplier for exporters @
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ to be corrected: multiplier for exporters @


clear zp0, vxiL, x1, tiH, tiL, sdz, nodes, inprob, y1, yN, ome, zs, zsL, P, j, k, unP, i, unP2, D_E, para1,paras, eei;
clear dH, dL, ip, dH, dL, Eintensity;
clear V0HL, V0, VH, VL, msp0, mspH, mspL, EV0, EVH, EVL, EV0f, EVHf, EVLf, V0_new, VH_new, VL_new;
clear zp0, fracp0, idxp0, zpH, fracpH, idxpH, zpL, fracpL, idxpL, z0, frac0, idx0, zH, fracH, idxH, zL, fracL, idxL;
clear DV0, DVH, DVL, z0, frac0, idx0, ms0, zH, fracH, idxH, msH, zL, fracL, idxL, msL;
clear m0, mH, mL, DT0, DT1, DTH, DTL, iter, DT00, DT01, DTH0, DTH1, DTL0, DTL1, DT0new, DTHnew, DTLnew, tol;
clear SD0, SD01, SD10, SD1H, SD1L, n_0, n_1, n_X; 
clear DE0s, DEHs, DELs, DE00, DE01, DEH0, DEH1, DEL0, DEL1, DE0new, DEHnew, DELnew, Exit5; 
clear Int0, IntH, IntL, IntT, eei, L_0, L_L, L_H, L_T, Ly0, DDT00, DDT01, DDTH0, DDTH1, DDTL0, DDTL1, Ld0, shutdown;
clear wgtL, L_0D, L_LD, L_HD, L_cof, i, L_cmfe, L_cmfl, L_pmfe, L_pmfl, L_cofx, L_cmf3, L_cmf4, L_cmfx, L_pmf3, L_pmf4, L_pmfx;
clear vft01, Eintensityall, EEi00;

@----  producing output values given parameters  ----@ 
@ Given parameter values computes distributions      @
@ to match        @
@----------------------------------------------------@


para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

@---------------------------------------------------------@
@---  Calibration of productivity parameters -------------@
@---------------------------------------------------------@


Xss0 = ln((f_0-f_1)|f_1);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01,Xss0);

/*


Xss0 = ln((f_0-f_1)|f_1|xiH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01xiH,Xss0);


Xss0 = ln((f_0-f_1)|f_1|rhoH|xiH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoHxiH,Xss0);


Xss0 = ln((f_0-f_1)|f_1|rhoH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoH,Xss0);

Xss0 = ln(lamD|nd0|muE);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&lamndmu,Xss0);


Xss0 = ln((f_0-f_1)|f_1);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01,Xss0);


Xss0 = ln((f_0-f_1)|f_1|rhoH);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01rhoH,Xss0);



Xss0 = ln((f_0-f_1)|f_1|lamD|rhoH|nd0|muE);
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&fT01all1,Xss0);


Xss0 = ln((f_0-f_1)|f_1|lamD|rhoH|nd0|muE|(1-rho));
vfT01  = zeros(rows(Xss0),1);
{xout,fout,gout,cout}=optmum(&Paraall,Xss0);
*/



Eintensityall = DTH.*ta^(-th)*xiH^(1-th)/( 1 + ta^(-th)*xiH^(1-th) ) + DTL.*ta^(-th)*xiL^(1-th)/( 1 + ta^(-th)*xiL^(1-th) );
Eintensityall = sumc(Eintensityall)/sumc(DTH+DTL);
EEi00 = ta^(-th)*xiH^(1-th)/( 1 + ta^(-th)*xiH^(1-th) );
?"    Eintensityall=";;Eintensityall;
?"    Eintensity0  =";;EEi00;
?"    ratio        =";;EEi00/Eintensityall;
?;






format /rdn 15,8;
?;
?;
?"   sde =";;sde;;"; rho =";;rho;;";  muE =";;muE;;";";
?"   lamD=";;lamD;;"; nd0 =";;nd0;;";  f_T =";;f_T;;";  f_0 =";;f_0;;"; f_1  =";;f_1;;";";
?"   xiL =";;xiL;;"; xiH =";;xiH;;"; rhoH =";;rhoH;;"; rhoL =";;rhoL;;";";
?;
?"   Note: Here f_0 and f_1 are normalized costs ";
?;

format /rdn 20,3;
?"    ---------------------------------------------------";
?"    ---------- 5 Parameters f0, f1, muE, nd0, lamD ----";
?"    ---------- selected to match ----------------------";
?"    ---------------------------------------------------";
?"    Entrants' labor share            (1.5%) ";;Ly0/L_T*100;
?"    Shutdown plants' labor share     (2.3%) ";;Ld0/L_T*100;
?"    Exporter Export Intensity: xi    (13.3%)";;eei*100;
?"    Stopper rate: n1                 (17.0%)";;n_1*100;
?"    Exporter rate: nx                (22.3%)";;n_x*100;
?"    Entrants' 5-year exit rate       (37.0%)";;Exit5*100;
?;
?"    f_T for Prob(Entrant in produciton)(80%)";;(1-cdfn((zp0+muE)/sdz))*100;
?;
?"    AND the DISTRIBUTIONS BELOW";
?;
?;

format /rdn 20,8;
?"    ------------ Establishments ------------";
?"          Employee(bin)         Model                Data";;
?(L_cof|maxc(L_LD[.,1]+1))~L_pmfe~pmfe_dat;
?;
stat_e = L_pmfe-pmfe_dat;
?"    RMSE ";;sqrt(meanc(stat_e^2))*100;
?;
?"    ------------ Employment ------------";
?"          Employee(bin)         Model                Data";;
?(L_cof|maxc(L_LD[.,1]+1))~L_pmfl~pmfl_dat;
?;
stat_l = L_pmfl-pmfl_dat;
?"    RMSE ";;sqrt(meanc(stat_l^2))*100;
?;
?"    ------------ Export Participation rate ------------";
?"          Employee(bin)         Model                Data";;
?(L_cofx|maxc(L_LD[.,1]+1))~L_pmfx~pmfx_dat;
?;
stat_x = pmfx_dat-L_pmfx;
?"    RMSE ";;sqrt(meanc(stat_x^2))*100;
?;
?;
?"    ------------ Establishment+Employment ------------";
?"    RMSE ";;sqrt(meanc((stat_e|stat_l)^2))*100;
?;
?"          sde                 RMSE  ";
?sde;;sqrt(meanc((stat_e|stat_l)^2))*100;
?;
?;

/*
?" @========================================@";
?" @======  STOPPER INNOVATION   ===========@";
?" @========================================@";
?;

DT1 = DTH+DTL;
DH = DTH/sumc(DT1);
DL = DTL/sumc(DT1);

ni = 500000;  @ total # of sample @
noHs = round(DH*ni);  @ assigning # of producers @
noLs = round(DL*ni);

MHz = 0; @ productivity @
MLz = 0; @ productivity @
i=1; do until i>nodes;
   if noHs[i]>0;
      MHz = MHz|(ones(noHs[i],1)*zs[i]);
   endif; 
   if noLs[i]>0;
      MLz = MLz|(ones(noLs[i],1)*zs[i]);
   endif;
i=i+1; endo;
noH = sumc(noHs);
noL = sumc(noLs);
ni  = noH+noL;  @ reset total # for rounding @

@ get rid of initial zero @
MHz = MHz[2:noH+1,.];
MLz = MLz[2:noL+1,.];

MHs = ones(noH,1);   @ initial survival status H type @
MLs = ones(noL,1);   @ initial survival status L type @

@-- exporting status -1 for H, 1 for L, 0 for non-exporters ---@ 
MHx = -ones(noH,1);   @ initial exporting status H type @
MLx = ones(noL,1);    @ initial exporting status L type @

@--- Stacking firms ---@
Ms = MHs|MLs;   
Mx = MHx|MLx;
Mz = MHz|MLz;

evalT = 6;  @ evaluation year starting from t=0 @

rndseed 13071;
i=1; do until i>evalT; 
   ez  = sde*rndn(ni,1); @ productivity shock @
   ex  = rndu(ni,1);     @ marginal cost shock @
   es  = rndu(ni,1);     @ survival shock @
   
   @ 1 if decide to export next period, 0 other wise @
   Mx0 = (Mz[.,i].>z0).*(Mx[.,i].==0) + (Mz[.,i].>zH).*(Mx[.,i].<0) + (Mz[.,i].>zL).*(Mx[.,i].>0); @ exporting decision at t @
   Mz  = Mz~( rho*Mz[.,i]+ez );           @ productivity t+1 @
   Ms  = Ms~( ( es.<n_S(Mz[.,i]) ).*Ms[.,i] );   @ survival at t+1 = 1 with exogenous shock @
   xis = ex.>( rhoL.*(Mx[.,i].>0) + rhoH.*(Mx[.,i].<0) );  @ indicator for switching xi, 1 for switching in t+1 @
   Mx  = Mx~( ( (1-xis).*Mx[.,i]-xis.*Mx[.,i] ).*Mx0 - (Mz[.,i].>z0).*(Mx[.,i].==0) ); @ exporting status in t+1, H=-1, 0=0, L=1 @
i=i+1; endo;

@ Select all time exporters until year 5 & stopper in year 6 & survivor = 1 @
SelM = abs(Mx[.,1]); 
i=2; do until i>evalT-1;
   SelM = SelM.*abs(Mx[.,i]);
i=i+1; endo;   
SelM = SelM.*(Mx[.,evalT].==0).*Ms[.,evalT];  @ stopper at evalT and survivor = (non zero)@
SelMx = Mx.*SelM;
SelMz = Mz.*SelM;
SelMx = delif(SelMx,SelMx[.,1].==0);
SelMz = delif(SelMz,SelMz[.,1].==0);
SelMx = SelMx[.,1:evalT-1];

Mxi = xiH*(SelMx.<0) + xiL*(SelMx.>0); @ marginal trade costs @
Mintensity =  ta^(-th)*Mxi^(1-th)./( 1 + ta^(-th)*Mxi^(1-th) );

MeanIntensity = meanc(Mintensity);
?" @===== Average intensity of stoppers (%) =====@ ";
?"          Year                mean(intensity) ";;   
?seqa(-evalT+1,1,evalT-1)~MeanIntensity*100;
?;
?;
*/

@---- Normalizing Distribution  N=1 @

DT  = sumc(DT0+DT1);
DT0  = DT0/DT;
DTH  = DTH/DT;
DTL  = DTL/DT;
DT1  = DTH+DTL;
D_E  = D_E;
DT00 = DT00/DT;
DT01 = DT01/DT;
DTH0 = DTH0/DT;
DTH1 = DTH1/DT;
DTL0 = DTL0/DT;
DTL1 = DTL1/DT;

n_E = sumc(D_E)/sumc(DT);
DT = sumc(DT0+DTH+DTL);

?" @========================================================================@";
?" @=============================  Initial SS ==============================@";
?" @========================================================================@";
?;
ta  = ta0;   @ initial tariff @
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ multiplier for exporters @
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ multiplier for exporters @

R     = 1/bet - 1 + del;   @ Rental rate of capital @

Int0  = exp(zs)'DT0;      @ Integration for non-exporters goods @
IntH  = exp(zs)'DTH;    @ Integration for H goods @   
IntL  = exp(zs)'DTL;    @ Integration for L goods @   
IntT  = Int0+IntH+IntL; @ Integration for all goods @   

S = ( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/( IntT + ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );
alpm = (1 - 1/2.8)*th/(th-1)*S;   @ matching Gross-VA = 2.8 @


clear N_TE, Y, MCN, PT, MCT, ti2, f_0n, f_1n, f_Tn, Lp, V0i, VLi, VHi, EXY, K_T, L_T, D; 

@ ---- Initial values for SS ---- @
K   = 0.5;
f_E = 6.04225614;
NT = 1;
C  = 0.21880511;
W  = 0.14808886;

Xss0=ln(K|f_E|alp|C|W);

Xss0 = 
    -2.88742538|
     1.79877748|
    -2.48512198|
    -1.51957387|
    -1.90994281;

convtol=di; prntit=0;
vSS0  = zeros(rows(Xss0),1);
Xss1 = nlsys(&ss0,Xss0,jc0,convtol,prntit,prntout);
format /rdn 15,8;
?xss1;
?;

gam = W*C^(-sig);

lambda = IntT/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );  @ domestic expenditure share @
IMD = ( ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/IntT; @ imported/domestic @

lambdas = lambda; @ stacking @
IMDs = IMD;      @ stacking @

@======  Resolving normalization =====@

ti2 = 1/th/( NT*IntT + ta^(1-th)*NT*( xiL^(1-th)*IntL + xiH^(1-th)*IntH ) )*S*Y/( S-alpm*(th-1)/th );
f_0 = f_0*ti2/W;
f_1 = f_1*ti2/W;


OP  = ( tiL*exp(zs)'DTL + tiH*exp(zs)'DTH )/( exp(zs)'DT0 )*sumc(DT0)/sumc(DT1); @ Output Premium @
PP  = (zs'DT1)/sumc(DT1) - (zs'DT0)/sumc(DT0); @ Productivity premium @
?;
?;
?"  check z0,zL,zH  (with normalization)     ";;z0~zL~zH;
{n_0new,n_1new,n_xnew} = n0n1nx(W*f_0|W*f_1|ti2);
@---- Normalizing Distribution  N=1 @
DT  = sumc(DT0+DT1);
DT0  = DT0/DT;
DTH  = DTH/DT;
DTL  = DTL/DT;
DT1  = DTH+DTL;
D_E  = D_E;
DT00 = DT00/DT;
DT01 = DT01/DT;
DTH0 = DTH0/DT;
DTH1 = DTH1/DT;
DTL0 = DTL0/DT;
DTL1 = DTL1/DT;
n_E = sumc(D_E)/sumc(DT);
DT = sumc(DT0+DTH+DTL);


?"  check z0,zL,zH (without normalization)   ";;z0~zL~zH;
?;
?;
format /rdn 15,8;
?;
?"    beta";;bet;;"  sigma";;sig;;" gamma";;gam;;"  theta";;th;
?"    alpm";;alpm;;" alpha";;alp;;"  delta";;del;
?"    f_T";;f_T;;"  f_0";;f_0;;"   f_1";;f_1;;"   f_E";;f_E;
?"    xiL";;xiL;;"   xiH";;xiH;;"   rhoH";;rhoH;;"   rhoL";;rhoL;;"  ta";;ta;
?"    sde";;sde;;"   rho";;rho;;"   lamD";;lamD;;"   muE";;muE;;"  nd0";;nd0;
?;
?;
format /rdn 15,8;
?"     tariff_rate    xiH            xiL             C              L              TR             LP             n_0            n_1            n_x";;
?"              NT           N_TE          IntX           Tradable_V     Effective_V    K              Y               W             OP";;
?"             PP             z0             zH             zL             lambda         IMD";
?ta~xiH~xiL~C~L~EXY~LP~n_0~n_1~n_x~NT~N_TE~(NT*(IntH+IntL))~(NT+n_x*NT)~(NT*IntT)~K~Y~W~OP~PP~z0~zH~zL~lambda~IMD;
?;


?;
?;
?"  Stats";
?"theta";;th;
?"alpha";;alp;
?"alphax";;alpm;
?"theta*kappaE";;th*f_E;
?"100*kappH/kappaE";;100*f_0/f_E;
?"xiH";;xiH;
?"xiL";;xiL;
?"rhoxi";;rhoH;
?"eta";;1;
?"kappaR/kappaL";;f_0/f_1;
?;

?" Payments of fixed costs relative to plant creation";
Fcostall = W*f_0*sumc(DT01) + W*f_1*sumc(DTH1+DTL1);
Fcreation = W*f_E*n_E;
?Fcostall/FCreation;
?;

?" Payments of fixed costs relative to export profits";
Fcostall = W*f_0*sumc(DT01) + W*f_1*sumc(DTH1+DTL1);
Xprofits = 1/((1-alp)*(1-alpm))/(th-1)*W*Lp*(IMD/(1+IMD));
?Fcostall/(Xprofits);

?;
"Starter ratio";
startX=(tiH-1)*exp(zs)'*P'( n_S(zs).*( DT01) )/sumc(P'( n_S(zs).*( DT01) )); 
aveX=( (tiL-1)*exp(zs)'DTL + (tiH-1)*exp(zs)'DTH )/sumc(DT1);
?"startX/aveX";;startX/aveX;
?;
?"Starter Export Share";
startX=(tiH-1)*exp(zs)'*P'( n_S(zs).*( DT01) ); 
aveX=( (tiL-1)*exp(zs)'DTL + (tiH-1)*exp(zs)'DTH );
?"startX/aveX";;startX/aveX;
?;

?" Exporter Premium";;
OP2  = ( tiL*exp(zs)'DTL + tiH*exp(zs)'DTH )/( exp(zs)'DT0 + tiL*exp(zs)'DTL + tiH*exp(zs)'DTH )/sumc(DT1); @ Output Premium @
?" Exporter/all average";;OP2;
?;
?"Aveage xi";
?((eei./(1-eei))*ta^th)^(1/(1-th)); @ same xi equivalent iceberg cost @
?;

@---- 20-year Innovation ----@

@---- DT0 ----@
DE0s  =DT0;
DEHs = 0*DE0s;
DELs = 0*DE0s;

iter=1; do until iter>20;
   @---- exporting decisions before exporting shocks ----@
   DE00 = (1-ms0).*DE0s[.,iter];
   DE01 = ms0.*DE0s[.,iter];
   DEH0 = (1-msH).*DEHs[.,iter];
   DEH1 = msH.*DEHs[.,iter];
   DEL0 = (1-msL).*DELs[.,iter];
   DEL1 = msL.*DELs[.,iter];

   @---- innovation after survival and productivity shocks----@
   DE0new = P'( n_S(zs).*( DE00 + DEH0 + DEL0 ) ); 
   DEHnew = P'( n_S(zs).*( DE01 + rhoH*DEH1 + (1-rhoL)*DEL1 ) ); 
   DELnew = P'( n_S(zs).*( (1-rhoH)*DEH1 + rhoL*DEL1 ) ); 

   DE0s = DE0s~DE0new;
   DEHs = DEHs~DEHnew;
   DELs = DELs~DELnew;
      
iter = iter+1; endo;

D0_0s = DE0s;
D0_Hs = DEHs;
D0_Ls = DELs;

@ == DTHs == @
DE0s  =DT0*0;
DEHs = DTH;
DELs = DTH*0;

iter=1; do until iter>20;
   @---- exporting decisions before exporting shocks ----@
   DE00 = (1-ms0).*DE0s[.,iter];
   DE01 = ms0.*DE0s[.,iter];
   DEH0 = (1-msH).*DEHs[.,iter];
   DEH1 = msH.*DEHs[.,iter];
   DEL0 = (1-msL).*DELs[.,iter];
   DEL1 = msL.*DELs[.,iter];

   @---- innovation after survival and productivity shocks----@
   DE0new = P'( n_S(zs).*( DE00 + DEH0 + DEL0 ) ); 
   DEHnew = P'( n_S(zs).*( DE01 + rhoH*DEH1 + (1-rhoL)*DEL1 ) ); 
   DELnew = P'( n_S(zs).*( (1-rhoH)*DEH1 + rhoL*DEL1 ) ); 

   DE0s = DE0s~DE0new;
   DEHs = DEHs~DEHnew;
   DELs = DELs~DELnew;
      
iter = iter+1; endo;

DH_0s = DE0s;
DH_Hs = DEHs;
DH_Ls = DELs;

@ == DTLs == @
DE0s  =DT0*0;
DEHs = DTH*0;
DELs = DTL;

iter=1; do until iter>20;
   @---- exporting decisions before exporting shocks ----@
   DE00 = (1-ms0).*DE0s[.,iter];
   DE01 = ms0.*DE0s[.,iter];
   DEH0 = (1-msH).*DEHs[.,iter];
   DEH1 = msH.*DEHs[.,iter];
   DEL0 = (1-msL).*DELs[.,iter];
   DEL1 = msL.*DELs[.,iter];

   @---- innovation after survival and productivity shocks----@
   DE0new = P'( n_S(zs).*( DE00 + DEH0 + DEL0 ) ); 
   DEHnew = P'( n_S(zs).*( DE01 + rhoH*DEH1 + (1-rhoL)*DEL1 ) ); 
   DELnew = P'( n_S(zs).*( (1-rhoH)*DEH1 + rhoL*DEL1 ) ); 

   DE0s = DE0s~DE0new;
   DEHs = DEHs~DEHnew;
   DELs = DELs~DELnew;
      
iter = iter+1; endo;

DL_0s = DE0s;
DL_Hs = DEHs;
DL_Ls = DELs;


@ ===== NEW EXPORTERS ===== @ 

NSD01 = sumc(SD01);     @ # of new exporters @
XSD01 = SD01'exp(zs)*(tiH-1);  @ exports of new exporters @
XDX   = exp(zs)'DTH*(tiH-1) + exp(zs)'DTL*(tiL-1);    @ exports of all exporters @   
DTX = sumc(DTH+DTL);

nxnew = NSD01/sumc(DTX);  @ # of new exporters among exporters @
Xnewshare = XSD01/XDX;        @ new exporters' export share @  


@ ==== tn years later ====@
tn = 6;

ND0tn = sumc(D0_Hs[.,tn]+D0_Ls[.,tn]);  @ # of exporters tn years later among initial non-exporters @
XD0tn = (D0_Hs[.,tn])'exp(zs)*(tiH-1) + (D0_Ls[.,tn])'exp(zs)*(tiL-1);  @ exports of non-exporters tn years ago @

nx0tn = ND0tn/sumc(DTX);  @ # of new exporters among exporters @
X0tnshare = XD0tn/XDX;        @ new exporters' export share @  

ND1tn = sumc(DH_Hs[.,tn]+DH_Ls[.,tn]+DL_Hs[.,tn]+DL_Ls[.,tn]);  @ # of exporters tn years later among initial exporters @
XD1tn = (DH_Hs[.,tn]+DL_Hs[.,tn])'exp(zs)*(tiH-1) + (DH_Ls[.,tn]+DL_Ls[.,tn])'exp(zs)*(tiL-1);  @ exports of exporters tn years ago @

nx1tn = ND1tn/sumc(DTX);  @ # of exporters that exported tn years ago among exporters @
X1tnshare = XD1tn/XDX;    @ exporters' export share for firms exported tn years ago @  


@ ===== NEW EXPORTERS BALANCED ===== @ 
ND2 = sumc(D0_Hs[.,2]+DH_Hs[.,2]+DL_Hs[.,2]+D0_Ls[.,2]+DH_Ls[.,2]+DL_Ls[.,2]);  @ exports of all firms exisited 2 years ago @
XD2 = (D0_Hs[.,2]+DH_Hs[.,2]+DL_Hs[.,2])'exp(zs)*(tiH-1) 
      + (D0_Ls[.,2]+DH_Ls[.,2]+DL_Ls[.,2])'exp(zs)*(tiL-1);  @ exports of all firms exisited 2 years ago @

nxnew2 = NSD01/ND2;  @ # of new exporters among exporters @
Xnewshare2 = XSD01/XD2;        @ new exporters' export share @  


@ ==== tn years later  BALANCED ====@
NDtn = sumc(D0_Hs[.,tn]+DH_Hs[.,tn]+DL_Hs[.,tn]+D0_Ls[.,tn]+DH_Ls[.,tn]+DL_Ls[.,tn]);  @ exports of all firms existed 2 years ago @
XDtn = (D0_Hs[.,tn]+DH_Hs[.,tn]+DL_Hs[.,tn])'exp(zs)*(tiH-1) 
      + (D0_Ls[.,tn]+DH_Ls[.,tn]+DL_Ls[.,tn])'exp(zs)*(tiL-1);  @ exports of all firms exisited 2 years ago @

nxnewtn = ND0tn/NDtn;  @ # of new exporters among exporters @
Xnewsharetn = XD0tn/XDtn;        @ new exporters' export share @  


?"    % of 5y ago exporters        (33.9%)";;nx1tn*100;
?"    5y ago exporters' export share(13.7%)";;X1tnshare*100;

?"    % of 5y ago non-exporters        (57.2%)";;nxnewtn*100;
?"    5y ago nonexporters' export share(38.4%)";;Xnewsharetn*100;

end;






































?" @============================================================@";
?" @=============== Initial Steady State (Again) ===============@";
?" @============================================================@";
?;
ta  = ta0;
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ multiplier for exporters @
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ multiplier for exporters @

convtol=di; prntit=0;  
format /rdn 15,8;
iter2 = 1; do until iter2>10;

   DT0_old = DT0;
   DT1_old = DT1;
   DTH_old = DTH;
   DTL_old = DTL;
   z0old = z0;
   zLold = zL;
   zHold = zH;
   Kold = K;
   Cold = C;
   Wold = W;
   NTold = NT;
   
   Xss0=ln(K|NT|C|W|L);
   vSS1  = zeros(rows(Xss0),1);
   Xss1 = nlsys(&SS1,Xss0,jc0,convtol,prntit,prntout);

   {n_0,n_1,n_x} = n0n1nx(W*f_0|W*f_1|ti2);
   @ normalizing distribution sum=1 @
   DT  = sumc(DT0+DT1);
   DT0  = DT0/DT;
   DTH  = DTH/DT;
   DTL  = DTL/DT;
   DT1  = DTH+DTL;
   D_E  = D_E;
   DT00 = DT00/DT;
   DT01 = DT01/DT;
   DTH0 = DTH0/DT;
   DTH1 = DTH1/DT;
   DTL0 = DTL0/DT;
   DTL1 = DTL1/DT;

   n_E = sumc(D_E)/sumc(DT);
   DT = sumc(DT0+DTH+DTL);

   Int0  = exp(zs)'DT0;      @ Integration for domestic tradable goods @
   IntH  = exp(zs)'DTH;    @ Integration for imported goods @   
   IntL  = exp(zs)'DTL;    @ Integration for imported goods @   
   IntT  = Int0+IntH+IntL; 

   tol1 = maxc(abs((DT0|DTH|DTL)-(DT0_old|DTH_old|DTL_old)));
   tol3 = maxc(abs((z0|zH|zL)-(z0old|zHold|zLold)));
   tol4 = maxc(abs((K|NT|C|W)-(Kold|NTold|Cold|Wold)));
   iter2 = 100*(maxc(tol1|tol3|tol4).<di);

   OP  = ( tiL*exp(zs)'DTL + tiH*exp(zs)'DTH )/( exp(zs)'DT0 )*sumc(DT0)/sumc(DT1); @ Output Premium @
   PP  = (zs'DT1)/sumc(DT1) - (zs'DT0)/sumc(DT0); @ Productivity premium @

endo; @ iteration for iter2 @

lambda = IntT/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );  @ domestic expenditure share @
IMD = ( ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/IntT; @ imported/domestic @

lambdas = lambda; @ stacking @
IMDs = IMD;      @ stacking @


format /rdn 15,8;
?"     tariff_rate    xiH            xiL             C              L              TR             LP             n_0            n_1            n_x";;
?"              NT           N_TE          IntX           Tradable_V     Effective_V    K              Y               W             OP";;
?"             PP             z0             zH             zL             lambda         IMD";
?ta~xiH~xiL~C~L~EXY~LP~n_0~n_1~n_x~NT~N_TE~(NT*(IntH+IntL))~(NT+n_x*NT)~(NT*(IntT+IntH+IntL))~K~Y~W~OP~PP~z0~zH~zL~lambda~IMD;
?;
C0ss = C;
L0ss = L;

SSout = ta~xiH~xiL~C~L~EXY~LP~n_0~n_1~n_x~NT~N_TE~(NT*(IntH+IntL))~(NT+n_x*NT)~(NT*IntT)~K~Y~W~OP~PP~z0~zH~zL~lambda~IMD;

@ ====  Saving values of key variables ====@
vec0  = C|L|W|N_TE|K|R;
z0HLV0 = z0|zH|zL;
Dist0V0 = NT*DT0;
DistHV0 = NT*DTH;
DistLV0 = NT*DTL;
V0iV0  = V0i;  
VHiV0  = VHi;  
VLiV0  = VLi;  
Addat0 = C~L~EXY~LP~n_0~n_1~n_X~OP~PP~NT~N_TE~(NT*IntT)~(Nt*Int0)~(Nt*IntH)~(NT*IntL)~(NT+n_x*NT)~K~Y~W~(del*K)~(IntT+ta^(-th)*(xiH^(1-th)*IntH+xiL^(1-th)*IntL))~z0~zH~zL~lambda~IMD;



?" @============================================================@";
?" @=============== New Steady State ===========================@";
?" @============================================================@";
?;
/*
xiL = xiL*exp(-0.1);
xiH = xiH*exp(-0.1);
*/
ta  = ta1;
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ multiplier for exporters @
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ multiplier for exporters @

convtol=di; prntit=0;  
format /rdn 15,8;
iter2 = 1; do until iter2>10;

   DT0_old = DT0;
   DT1_old = DT1;
   DTH_old = DTH;
   DTL_old = DTL;
   z0old = z0;
   zLold = zL;
   zHold = zH;
   Kold = K;
   Cold = C;
   Wold = W;
   NTold = NT;

   Int0  = exp(zs)'DT0;      @ Integration for domestic tradable goods @
   IntH  = exp(zs)'DTH;    @ Integration for imported goods @   
   IntL  = exp(zs)'DTL;    @ Integration for imported goods @   
   IntT  = Int0+IntH+IntL; 

   Xss0=ln(K|NT|C|W|L);
   vSS1  = zeros(rows(Xss0),1);
   Xss1 = nlsys(&SS1,Xss0,jc0,convtol,prntit,prntout);

   {n_0,n_1,n_x} = n0n1nx(W*f_0|W*f_1|ti2);
   @ normalizing distribution sum=1 @
   DT  = sumc(DT0+DT1);
   DT0  = DT0/DT;
   DTH  = DTH/DT;
   DTL  = DTL/DT;
   DT1  = DTH+DTL;
   D_E  = D_E;
   DT00 = DT00/DT;
   DT01 = DT01/DT;
   DTH0 = DTH0/DT;
   DTH1 = DTH1/DT;
   DTL0 = DTL0/DT;
   DTL1 = DTL1/DT;

   n_E = sumc(D_E)/sumc(DT);
   DT = sumc(DT0+DTH+DTL);

   tol1 = maxc(abs((DT0|DTH|DTL)-(DT0_old|DTH_old|DTL_old)));
   tol3 = maxc(abs((z0|zH|zL)-(z0old|zHold|zLold)));
   tol4 = maxc(abs((K|NT|C|W)-(Kold|NTold|Cold|Wold)));
   iter2 = 100*(maxc(tol1|tol3|tol4).<di);

   OP  = ( tiL*exp(zs)'DTL + tiH*exp(zs)'DTH )/( exp(zs)'DT0 )*sumc(DT0)/sumc(DT1); @ Output Premium @
   PP  = (zs'DT1)/sumc(DT1) - (zs'DT0)/sumc(DT0); @ Productivity premium @

endo; @ iteration for iter2 @

lambda = IntT/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );  @ domestic expenditure share @
IMD = ( ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/IntT; @ imported/domestic @

lambdas = lambdas|lambda; @ stacking @
IMDs = IMDs|IMD;      @ stacking @


format /rdn 15,8;
?"     tariff_rate    xiH            xiL             C              L              TR             LP             n_0            n_1            n_x              NT           N_TE";;
?"          IntX           Tradable_V     Effective_V    K              Y               W             OP            PP";;
?"          z0             zH            zL              lambda         IMD";
?ta~xiH~xiL~C~L~EXY~LP~n_0~n_1~n_x~NT~N_TE~(NT*(IntH+IntL))~(NT+n_x*NT)~(NT*(IntT+IntH+IntL))~K~Y~W~OP~PP~z0~zH~zL~lambda~IMD;
?;

WG = ln(C/C0ss)*100;

?" @====================================================@";
?"    LR Welfare Gains in Consumpson (%)";;WG; 
?" @====================================================@";

@ ====  Saving values of key variables ====@
vec1  = C|L|W|N_TE|K|R;
z0HLV1 = z0|zH|zL;
Dist0V1 = NT*DT0;
DistHV1 = NT*DTH;
DistLV1 = NT*DTL;
V0iV1  = V0i;  
VHiV1  = VHi;  
VLiV1  = VLi;  
Addat1 = C~L~EXY~LP~n_0~n_1~n_X~OP~PP~NT~N_TE~(NT*IntT)~(Nt*Int0)~(Nt*IntH)~(NT*IntL)~(NT+n_x*NT)~K~Y~W~(del*K)~(NT*IntT+ta^(-th)*NT*(xiH^(1-th)*IntH+xiL^(1-th)*IntL))~z0~zH~zL~lambda~IMD;

@ =================================================== @
@ ==========  Iteration for Transitions ============= @
@ =================================================== @

clear EV0t1, EVHt1, EVLt1, DV0t1, DVHt1, DVLt1, z0t1new, zHt1new, zLt1new, frac0t1, fracHt1, fracLt1, idx0t1, idxHt1, idxLt1, ms0t1, msHt1, msLt1;
clear EV0ft1, EVHft1, EVLft1, V0it1, VHit1, VLit1, D1, D2, D3, R1, R2, R3, K0, K1, K2, K3,
      z0t1new, frac0t1, idx0t1, ms0t1, zHt1new, fracHt1, idxHt1, msHt1, zLt1new, fracLt1, idxLt1, msLt1, 
      zp0t1new, fracp0t1, idxp0t1, msp0t1, zpHt1new, fracpHt1, idxpHt1, mspHt1, zpLt1new, fracpLt1, idxpLt1, mspLt1, m0t1, mHt1, mLt1; 
clear msp0, mspH, mspL, ms0, msH, msL, D00, D01, DH0, DH1, DL0, DL1, 
      D0new, DHnew, DLnew, D0new, DHnew, DLnew, D1new, 
      SD0, SD01, SD10, SD1H, SD1L, n_0new, n_1new, n_Xnew;
clear L1, W1, K1, N_TE1, L2, W2, N_TE2, N_TE0, 
      zp0t0, zpHt0, zpLt0, z0t0, zHt0, zLt0, zp0t1, zpHt1, zpLt1, z0t1, zHt1, zLt1, zp0t2, zpHt2, zpLt2, z0t2, zHt2, zLt2, zp0t3, zpHt3, zpLt3,
      K0, K2, L3, W3, C1, C2, C3, UC1, UC2, UC3, UL1, UL2, UL3, 
      DT0t0, DTHt0, DTLt0, DT1t0, DT00t0, DT01t0, DTH0t0, DTH1t0, DTL0t0, DTL1t0, DT0t1, DTHt1, DTLt1, DT1t1, n_0t1, n_1t1, n_xt1,
      DT00t1, DT01t1, DTH0t1, DTH1t1, DTL0t1, DTL1t1, DT0t2, DTHt2, DTLt2, DT1t2, n_0t2, n_1t2, n_xt2, 
      DT00t2, DT01t2, DTH0t2, DTH1t2, DTL0t2, DTL1t2, DT0t3, DTHt3, DTLt3, DT1t3, n_0t3, n_1t3, n_xt3, 
      IntT1, IntT2, IntT3, IntH1, IntL1, IntH2, IntL2, IntH3, IntL3, NT1, NT2, V0it2, VHit2, VLit2, V0it3, VHit3, VLit3,
      Y1, S1, Lp1, R1, MCN1, PT1, MCT1, EXY1, PPt1, OPt1, Y2, S2, Lp2, R2, MCN2, PT2, MCT2, 
      EV0t2, EVHt2, EVLt2, EV0ft2, EVHft2, EVLft2, msp0t2, mspHt2, mspLt2; 

@============  Matrices for Transitions ============@
T = 300+4;       @ # of periods for the transition @
bound = T-2;   @ Set initial guess based on initial and new steady states @
@bound = T-100;@
@------- Matrices for transtion dynamics --------@
Dats1 = ones(T,1).*vec0'; 
z0HLs1 = ones(T,1).*z0HLV0'; 
Dist0s1 = ones(T,1).*Dist0V0';
DistHs1 = ones(T,1).*DistHV0';
DistLs1 = ones(T,1).*DistLV0';
V0is1 = ones(T,1).*V0iV0';
VHis1 = ones(T,1).*VHiV0';
VLis1 = ones(T,1).*VLiV0';

Dats1[rows(Dats1)-bound:rows(Dats1),.] = ones(bound+1,1).*vec1';      @ C W NTE K R @
z0HLs1[rows(z0HLs1)-bound:rows(z0HLs1),.] = ones(bound+1,1).*z0HLV1'; @ Z0 ZH  ZL @
Dist0s1[rows(Dist0s1)-bound:rows(Dist0s1),.] = ones(bound+1,1).*Dist0V1';
DistHs1[rows(DistHs1)-bound:rows(DistHs1),.] = ones(bound+1,1).*DistHV1';
DistLs1[rows(DistLs1)-bound:rows(DistLs1),.] = ones(bound+1,1).*DistLV1';
V0is1[rows(V0is1)-bound:rows(V0is1),.] = ones(bound+1,1).*V0iV1';
VHis1[rows(VHis1)-bound:rows(VHis1),.] = ones(bound+1,1).*VHiV1';
VLis1[rows(VLis1)-bound:rows(VLis1),.] = ones(bound+1,1).*VLiV1';


@load Dats1, z0HLs1, Dist0s1, DistHs1, DistLs1, V0is1, VHis1, VLis1;  T=rows(Dats1); @
@--- Trimming ---@
Trt = T-100;
Dats1[Trt:T,.]   =  ones(T-Trt+1,cols(Dats1)).*Dats1[T,.];
z0HLs1[Trt:T,.]  =  ones(T-Trt+1,cols(z0HLs1)).*z0HLs1[T,.];
Dist0s1[Trt:T,.] =  ones(T-Trt+1,cols(Dist0s1)).*Dist0s1[T,.];
DistHs1[Trt:T,.] =  ones(T-Trt+1,cols(DistHs1)).*DistHs1[T,.];
DistLs1[Trt:T,.] =  ones(T-Trt+1,cols(DistLs1)).*DistLs1[T,.];
V0is1[Trt:T,.]   =  ones(T-Trt+1,cols(V0is1)).*V0is1[T,.];
VHis1[Trt:T,.]   =  ones(T-Trt+1,cols(VHis1)).*VHis1[T,.];
VLis1[Trt:T,.]   =  ones(T-Trt+1,cols(VLis1)).*VLis1[T,.];

/*
Textend = 100;
@-----  Extending period -----@
Dats1   =  Dats1|( ones(Textend,cols(Dats1)).*Dats1[T,.] );
z0HLs1  =  z0HLs1|( ones(Textend,cols(z0HLs1)).*z0HLs1[T,.] );
Dist0s1 =  Dist0s1|( ones(Textend,cols(Dist0s1)).*Dist0s1[T,.] );
DistHs1 =  DistHs1|( ones(Textend,cols(DistHs1)).*DistHs1[T,.] );
DistLs1 =  DistLs1|( ones(Textend,cols(DistLs1)).*DistLs1[T,.] );
V0is1   =  V0is1|( ones(Textend,cols(V0is1)).*V0is1[T,.] );
VHis1   =  VHis1|( ones(Textend,cols(VHis1)).*VHis1[T,.] );
VLis1   =  VLis1|( ones(Textend,cols(VLis1)).*VLis1[T,.] );
*/

Dats2  = Dats1;
z0HLs2  = z0HLs1;
Dist0s2 =  Dist0s1;
DistHs2 =  DistHs1;
DistLs2 =  DistLs1;
V0is2   =  V0is1;
VHis2   =  VHis1;
VLis2   =  VLis1;

 
count = 1;   @ iteration counting @
wg    = 1;   @ weight for updating @
strt0 = 1;   @ if 0, take N_TE1(idxst0) = 0 @
idxst0 = 3;  @ period+1 where the N_TE=0 occurs @
flexL = 1; 
/*
vec1  = C|L|W|N_TE|R;
z0HLV1 = z0|zH|zL|zp0|zpH|zpL;
*/
dit=1e-5; convtol=1e-6; prntit=0;
iter = 1; do until iter>5;
   if count>100; wg = 1; endif;
   i=2; do until i>T-4;
      j=1; do until j>5;  @ Dats = [C W NTE K R] @
        
         @ Using L @
         x0=( ln(dats2[i,1 3 5])~(dats2[i,4])~ln(dats2[i+1,1 3])~(dats2[i+1,4]) )';   @ C|L|W|N_TE|K|R @
         vf=zeros(rows(x0),1);
         x1=nlsys(&trans,x0,jc0,convtol,prntit,prntout); 
         
         {z0t1new, zHt1new, zLt1new}=fIntX(V0it2,VHit2,VLit2);
         j=100*( maxc(abs( (z0t1new|zHt1new|zLt1new)-(z0t1|zHt1|zLt1) )).<dit );
         
         z0t1  = z0t1new;
         zHt1  = zHt1new;
         zLt1  = zLt1new;
         
         z0HLs2[i,.] = (z0t1|zHt1|zLt1)';
         dats2[i,1:6]   = C1~L1~W1~N_TE1~K1~R1;
         V0is2[i+1,.] = V0it2';    @ value next period @
         VHis2[i+1,.] = VHit2';    @ value next period @
         VLis2[i+1,.] = VLit2';    @ value next period @
         V0is2[i,.] = V0it1';    @ value next period @
         VHis2[i,.] = VHit1';    @ value next period @
         VLis2[i,.] = VLit1';    @ value next period @
      endo; @ iteration for j @
      
      @ Updating L @
      @L1 = Lbar-(1-gam)/gam*C1/W1;@

      dats2[i,1:6] = C1~L1~W1~N_TE1~K1~R1;
      @dats2[i+1,2] = L2;@
      z0HLs2[i,.]  = (z0t1|zHt1|zLt1)';
      Dist0s2[i,.] = DT0t1';    @ avaialble next period @
      DistHs2[i,.] = DTHt1';    @ avaialble next period @
      DistLs2[i,.] = DTLt1';    @ avaialble next period @
      V0is2[i+1,.] = V0it2';    @ value next period @
      VHis2[i+1,.] = VHit2';    @ value next period @
      VLis2[i+1,.] = VLit2';    @ value next period @
      V0is2[i,.] = V0it1';    @ value next period @
      VHis2[i,.] = VHit1';    @ value next period @
      VLis2[i,.] = VLit1';    @ value next period @
      
   i=i+1; endo;

   converg = maxc( maxc( abs(dats1-dats2) ) );  @ you can add more variables to the convergence criterion. But, results are pretty much the same @ 
   iter = 100*(converg.<dit);
   format /rdn 20,8;
   ?count;;maxc( maxc( abs(dats1-dats2) ) );
   
   Dats2   =  wg*Dats2+(1-wg)*Dats1;
   z0HLs2  =  wg*z0HLs2+(1-wg)*z0HLs1;
   Dist0s2 =  wg*Dist0s2+(1-wg)*Dist0s1;
   DistHs2 =  wg*DistHs2+(1-wg)*DistHs1;
   DistLs2 =  wg*DistLs2+(1-wg)*DistLs1;
   V0is2   =  wg*V0is2+(1-wg)*V0is1;
   VHis2   =  wg*VHis2+(1-wg)*VHis1;
   VLis2   =  wg*VLis2+(1-wg)*VLis1;
   /*
   if count<50;  
      Trt = T-100;
      Dats2[Trt:T,.]   =  ones(T-Trt+1,cols(Dats1)).*Dats1[T,.];
      z0HLs2[Trt:T,.]  =  ones(T-Trt+1,cols(z0HLs1)).*z0HLs1[T,.];
      Dist0s2[Trt:T,.] =  ones(T-Trt+1,cols(Dist0s1)).*Dist0s1[T,.];
      DistHs2[Trt:T,.] =  ones(T-Trt+1,cols(DistHs1)).*DistHs1[T,.];
      DistLs2[Trt:T,.] =  ones(T-Trt+1,cols(DistLs1)).*DistLs1[T,.];
      V0is2[Trt:T,.]   =  ones(T-Trt+1,cols(V0is1)).*V0is1[T,.];
      VHis2[Trt:T,.]   =  ones(T-Trt+1,cols(VHis1)).*VHis1[T,.];
      VLis2[Trt:T,.]   =  ones(T-Trt+1,cols(VLis1)).*VLis1[T,.];
   endif;
   */
   /*
   if count<200; 
      Trt = T-50;
      Dats2[Trt:T,3]   =  ones(T-Trt+1,1).*Dats1[T,3];
   endif;
   */
   Dats1   =  Dats2;
   z0HLs1  =  z0HLs2;
   Dist0s1 =  Dist0s2;
   DistHs1 =  DistHs2;
   DistLs1 =  DistLs2;
   V0is1   =  V0is2;
   VHis1   =  VHis2;
   VLis1   =  VLis2;
   
count = count +1; endo; @ Convergence of iter @

save Dats1, z0HLs1, Dist0s1, DistHs1, DistLs1, V0is1, VHis1, VLis1;


@ ==========  Final Computations for Transitions ============= @
Addats = Addat0;
i=2; do until i>T-4;
   x0=( ln(dats2[i,1 3 5])~(dats2[i,4])~ln(dats2[i+1,1 3])~(dats2[i+1,4]) )';  @ C|L|W|N_TE|K|R @
   vf=zeros(rows(x0),1);
   @x1=nlsys(&trans,x0,jc0,convtol,prntit,prntout); @
   {vf}=trans(x0);
   lambdat1 = IntT1/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) );  @ domestic expenditure share @
   IMDt1 = ( ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )/IntT1; @ imported/domestic @
   Addats= Addats|
          (C1~L1~EXY1~LP1~n_0t1~n_1t1~n_Xt1~OPt1~PPt1~NT1~N_TE1~IntT1~(IntT1-IntH1-IntL1)~IntH1~IntL1~(NT1+n_xt1*NT1)
          ~K0~Y1~W1~(K1-(1-del)*K0)~(IntT1+ta^(-th)*(xiH^(1-th)*IntH1+xiL^(1-th)*IntL1))~z0t1~zHt1~zLt1~lambdat1~IMDt1 );
i=i+1; endo;
Addats = Addats|(ones(rows(dats1)-rows(Addats),cols(Addats)).*Addat1);

output on; format 15,8;
?"       Period   C  L   EXY  LP  n_0  n_1  n_X  OP  PP  NT  N_TE";;
?"    IntT    Int0  IntH  IntL  (NT+n_x*NT)  K0   Y     W     X";;
?"    (IntT+ta^(-th)*(xiH^(1-th)*IntH+xiL^(1-th)*IntL)) z0 zH zL lambda IMD";;
?seqa(0,1,rows(dats1))~Addats;




@=========================== BEGIN PROC TRANS(X) ======================================================@
/*  Transition Dynamics Computations   */
            
proc trans(x); @ Today 1 @

@ N_TE1 : Entrants Today @
@ NT1 : active firms today @
@ Distxx0: Firm distribution last period @

C1 = exp(x[1]); 
W1 = exp(x[2]);
K1 = exp(x[3]); 
N_TE1 = (x[4]);    @ decision Today, used tomorrow @
C2 = exp(x[5]); 
W2 = exp(x[6]); 
N_TE2 = (x[7]);    @ decision Today, used tomorrow @

z0t0  = z0HLs2[i-1,1];  @ Yesterday @
zHt0  = z0HLs2[i-1,2];  @ Yesterday @
zLt0  = z0HLs2[i-1,3];  @ Yesterday @

z0t1  = z0HLs2[i,1];  @ Today @
zHt1  = z0HLs2[i,2];  @ Today @
zLt1  = z0HLs2[i,3];  @ Today @

z0t2  = z0HLs2[i+1,1];  @ tomorrow @
zHt2  = z0HLs2[i+1,2];  @ tomorrow @
zLt2  = z0HLs2[i+1,3];  @ tomorrow @


N_TE0 = dats2[i-1,4];              @ Yesterday @
K0    = dats2[i-1,5];

@N_TE2 = dats2[i+1,4]; @
@N_TE1=maxc(0|N_TE1);@
@N_TE2=maxc(0|N_TE2);@


L1 = dats2[i,2];
R1 = dats2[i,6];

L2 = dats2[i+1,2];
K2 = dats2[i+1,5];
R2 = dats2[i+1,6];

C3 = dats2[i+2,1];
L3 = dats2[i+2,2];
W3 = dats2[i+2,3];
R3 = dats2[i+2,6];
/*
W1 = gam*C1^sig;
W2 = gam*C2^sig;
*/

UC1 = C1^(-sig);
UC2 = C2^(-sig);
UC3 = C3^(-sig);

DT0t0 = Dist0s2[i-1,.]'; @ Yesterday @
DTHt0 = DistHs2[i-1,.]'; 
DTLt0 = DistLs2[i-1,.]'; 
DT1t0 = DTHt0 + DTLt0;

{DT00t0, DT01t0, DTH0t0, DTH1t0, DTL0t0, DTL1t0, DT0t1, DTHt1, DTLt1, DT1t1, n_0t1, n_1t1, n_xt1} 
      = DistTs(z0t0,zHt0,zLt0,N_TE0,DT0t0,DTHt0,DTLt0);

{DT00t1, DT01t1, DTH0t1, DTH1t1, DTL0t1, DTL1t1, DT0t2, DTHt2, DTLt2, DT1t2, n_0t2, n_1t2, n_xt2} 
      = DistTs(z0t1,zHt1,zLt1,N_TE1,DT0t1,DTHt1,DTLt1);
      
{DT00t2, DT01t2, DTH0t2, DTH1t2, DTL0t2, DTL1t2, DT0t3, DTHt3, DTLt3, DT1t3, n_0t3, n_1t3, n_xt3} 
      = DistTs(z0t2,zHt2,zLt2,N_TE2,DT0t2,DTHt2,DTLt2);

IntT1 = exp(zs)'(DT0t1+DTHt1+DTLt1);
IntT2 = exp(zs)'(DT0t2+DTHt2+DTLt2);
IntT3 = exp(zs)'(DT0t3+DTHt3+DTLt3);

IntH1 = exp(zs)'DTHt1;
IntL1 = exp(zs)'DTLt1;

IntH2 = exp(zs)'DTHt2;
IntL2 = exp(zs)'DTLt2;

NT1  = sumc(DT0t1+DTHt1+DTLt1);
NT2  = sumc(DT0t2+DTHt2+DTLt2);

V0it2 = V0is2[i+1,.]';
VHit2 = VHis2[i+1,.]';
VLit2 = VLis2[i+1,.]';

V0it3 = V0is2[i+2,.]';
VHit3 = VHis2[i+2,.]';
VLit3 = VLis2[i+2,.]';


@W1 = ( th/(th-1)*(1/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )^(1/(1-th)) )^(-1/(1-alpm));@

Y1 = C1 + K1 - (1-del)*K0;
S1 = ( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )/( IntT1 + ta^(-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) );
D1 = S1*Y1/(S1-alpm*(th-1)/th);
Lp1 = (1-alp)*(1-alpm)*(th-1)/th*D1/S1/W1;

R1   = alp*(1-alpm)*(th-1)/th*D1/S1/K0;
MCN1 = (R1/alp)^(alp)*(W1/(1-alp))^(1-alp);
PT1  = ( th/(th-1)*(MCN1/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )^(1/(1-th)) )^(1/(1-alpm));
MCT1 = (alpm)^(-alpm)*(MCN1/(1-alpm))^(1-alpm);

EXY1 = ta^(-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 )/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1/Y1;
PPt1  = (zs'DT1t1)/sumc(DT1t1) - (zs'DT0t1)/sumc(DT0t1);
OPt1  = ( ( 1+ta^(-th)*xiH^(1-th) )*( exp(zs)'DTHt1 ) + ( 1+ta^(-th)*xiL^(1-th) )*( exp(zs)'DTLt1 ) )
         /( exp(zs)'DT0t1 )*sumc(DT0t1)/sumc(DT1t1);

@-------  t+2 ------@

@W2 = ( th/(th-1)*(1/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )^(1/(1-th)) )^(-1/(1-alpm));@

Y2 = C2 + K2-(1-del)*K1;
S2 = ( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )/( IntT2 + ta^(-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) );
D2 = S2*Y2/(S2-alpm*(th-1)/th);
Lp2 = (1-alp)*(1-alpm)*(th-1)/th*D2/S2/W2;

R2   = alp*(1-alpm)*(th-1)/th*D2/S2/K1;
MCN2 = (R2/alp)^(alp)*(W2/(1-alp))^(1-alp);
PT2  = ( th/(th-1)*(MCN2/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )^(1/(1-th)) )^(1/(1-alpm));
MCT2 = (alpm)^(-alpm)*(MCN2/(1-alpm))^(1-alpm);


EV0t2 = bet*UC3/UC2*n_S(zs).*(P*V0it3);  @ discounted expected value when m=0 row(z_today), col=1 @
EVHt2 = bet*UC3/UC2*n_S(zs).*(P*VHit3);  @ discounted expected value when m=1 row(z_today), col=1 @
EVLt2 = bet*UC3/UC2*n_S(zs).*(P*VLit3);  @ discounted expected value when m=1 row(z_today), col=1 @
 
@ expected value after payments decision @
EV0ft2 = maxc(EV0t2'|(EVHt2'-W2*f_0));  @ taking max @
EVHft2 = maxc(EV0t2'|((rhoH*EVHt2' + (1-rhoH)*EVLt2')-W2*f_1));  @ taking max @
EVLft2 = maxc(EV0t2'|(((1-rhoL)*EVHt2' + rhoL*EVLt2')-W2*f_1));  @ taking max @

V0it2 =   1/th/( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )*D2*exp(zs) + EV0ft2;
VHit2 = tiH/th/( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )*D2*exp(zs) + EVHft2;
VLit2 = tiL/th/( IntT2 + ta^(1-th)*( xiH^(1-th)*IntH2 + xiL^(1-th)*IntL2 ) )*D2*exp(zs) + EVLft2;


EV0t1 = bet*UC2/UC1*n_S(zs).*(P*V0it2);  @ discounted expected value when m=0 row(z_today), col=1 @
EVHt1 = bet*UC2/UC1*n_S(zs).*(P*VHit2);  @ discounted expected value when m=1 row(z_today), col=1 @
EVLt1 = bet*UC2/UC1*n_S(zs).*(P*VLit2);  @ discounted expected value when m=1 row(z_today), col=1 @
 
@ expected value after payments decision @
EV0ft1 = maxc(EV0t1'|(EVHt1'-W1*f_0));  @ taking max @
EVHft1 = maxc(EV0t1'|((rhoH*EVHt1' + (1-rhoH)*EVLt1')-W1*f_1));  @ taking max @
EVLft1 = maxc(EV0t1'|(((1-rhoL)*EVHt1' + rhoL*EVLt1')-W1*f_1));  @ taking max @

V0it1 =   1/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EV0ft1;
VHit1 = tiH/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EVHft1;
VLit1 = tiL/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EVLft1;

vf[1] = bet*UC2/UC1*(V0it2'D_E) - W1*f_E;

if (i==idxst0).and (strt0==0); 
   vf[1] = N_TE1;
endif;

vf[2] = (Lp1 + f_E*N_TE1 + f_0*sumc(DT01t1) + f_1*sumc(DTH1t1+DTL1t1)) - L1;

vf[3] = (Lp2 + f_E*N_TE2 + f_0*sumc(DT01t2) + f_1*sumc(DTH1t2+DTL1t2)) - L2;

vf[4] = bet*UC3/UC2*(V0it3'D_E) - W2*f_E;

vf[5] = PT1 - 1;

vf[6] = PT2 - 1;

vf[7] = bet*UC2/UC1*(R2 + 1 - del ) - 1;

retp(vf);
endp;
@=========================== END PROC TRANS(X) ======================================================@












@=========================== BEGIN PROC DistTs(x) ======================================================@
 /* 1-Period Innovation of Distributions during  transitions */

proc(13)=DistTs(z0,zH,zL,NTE1,D0,DH,DL);

   ms0  = findm(z0);
   msH  = findm(zH);
   msL  = findm(zL);
   
   D00 = (1-ms0).*D0;
   D01 = ms0.*D0;
   DH0 = (1-msH).*DH;
   DH1 = msH.*DH;
   DL0 = (1-msL).*DL;
   DL1 = msL.*DL;
   
   @---- innovation after survival and productivity shocks----@
   D0new = P'( n_S(zs).*( D00 + DH0 + DL0 ) ) + D_E*NTE1; 
   DHnew = P'( n_S(zs).*( D01 + rhoH*DH1 + (1-rhoL)*DL1 ) ); 
   DLnew = P'( n_S(zs).*( (1-rhoH)*DH1 + rhoL*DL1 ) ); 
   D1new = DHnew+DLnew;
   
   SD0  = P'( n_S(zs).*D0 ); @ survived last period non-exporters @
   SD01 = P'( n_S(zs).*D01); @ survived starters @

   SD10 = P'( n_S(zs).*( DH0 + DL0 ) );  @ survived last period exporters being non-exporters @
   SD1H = P'( n_S(zs).*( rhoH*DH1 + (1-rhoL)*DL1 ) ); @ survived last period exporters being H @
   SD1L = P'( n_S(zs).*( (1-rhoH)*DH1 + rhoL*DL1 ) ); @ survived last period exporters being L @

   n_0new = sumc(SD01)/sumc(SD0);                     @ starter rate @
   n_1new = sumc(SD10)/sumc(SD10+SD1H+SD1L);          @ stopper rate @
   n_Xnew = sumc(D1new)/sumc(D0new+D1new);                     @ exporter ratio @


retp(D00, D01, DH0, DH1, DL0, DL1, D0new, DHnew, DLnew, D1new, n_0new, n_1new, n_Xnew);
endp;
   
@=========================== END PROC DistTs(x) ======================================================@




@=========================== BEGIN PROC fIntX(x) ======================================================@
 /* 1-Period Innovation of Distributions during  transitions */

proc(3)=fIntX(V0it2,VHit2,VLit2);

EV0t1 = bet*UC2/UC1*n_S(zs).*(P*V0it2);  @ discounted expected value when m=0 row(z_today), col=1 @
EVHt1 = bet*UC2/UC1*n_S(zs).*(P*VHit2);  @ discounted expected value when m=1 row(z_today), col=1 @
EVLt1 = bet*UC2/UC1*n_S(zs).*(P*VLit2);  @ discounted expected value when m=1 row(z_today), col=1 @
 
@ expected value after payments decision @
EV0ft1 = maxc(EV0t1'|(EVHt1'-W1*f_0));  @ taking max @
EVHft1 = maxc(EV0t1'|((rhoH*EVHt1' + (1-rhoH)*EVLt1')-W1*f_1));  @ taking max @
EVLft1 = maxc(EV0t1'|(((1-rhoL)*EVHt1' + rhoL*EVLt1')-W1*f_1));  @ taking max @

DV0t1 = ( EVHt1 - W1*f_0 ) - EV0t1;
DVHt1 = ( (rhoH*EVHt1 + (1-rhoH)*EVLt1) - W1*f_1 ) - EV0t1;
DVLt1 = ( ((1-rhoL)*EVHt1 + rhoL*EVLt1) - W1*f_1 ) - EV0t1;

{z0t1new,frac0t1,idx0t1,ms0t1}= Cutoff(DV0t1);
{zHt1new,fracHt1,idxHt1,msHt1}= Cutoff(DVHt1);
{zLt1new,fracLt1,idxLt1,msLt1}= Cutoff(DVLt1);

V0it1 =   1/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EV0ft1;
VHit1 = tiH/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EVHft1;
VLit1 = tiL/th/( IntT1 + ta^(1-th)*( xiH^(1-th)*IntH1 + xiL^(1-th)*IntL1 ) )*D1*exp(zs) + EVLft1;

  
retp(z0t1new, zHt1new, zLt1new);

endp;
   
@=========================== END PROC fIntX(x) ======================================================@




@--------------- BEGIN PROC findm(x) -------------------@
@---- Given Val, find Val(i)=0, and fraction   ----------@
@--------------------------------------------------------@
proc(1)= findm(zt);
   local zall, mt, idx;
 
   zall = zsL|(zsL[nodes]+ome);
   mt   = zall.>zt;  @ take 1 for z(i)>zt otherwise take 0 @
   idx  = nodes+1-sumc(mt);
   if idx<nodes+1;
      mt[idx] = (zall[idx+1]-zt)/ome;
   endif;
   mt = mt[1:nodes,.];
retp(mt);   
endp;
@--------------- END PROC findm(x) -------------------@





















































@=========================== BEGIN PROC SS1(x) ======================================================@
/*
   Compute the new Steady State
*/

proc SS1(x);

local tol, i, iter, V0i_new, VLi_new, VHi_new;

K   = exp(x[1]);  @ capital @
NT  = exp(x[2]);  @ mass of tradable good producers @
C   = exp(x[3]);  @ consumption @
W   = exp(x[4]);  @ Wage rate @
L   = exp(x[5]);  @ Wage rate @

N_TE = NT*n_E;    @ mass of tradable good entrants @

Y    = C + del*K;    @ Absorption @
S    = ( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/( IntT + ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );
D    = S*Y/( S-alpm*(th-1)/th );
MCN  = (R/alp)^(alp)*(W/(1-alp))^(1-alp);  
PT   = ( th/(th-1)*(MCN/(1-alpm))^(1-alpm)*alpm^(-alpm)*( NT*IntT + ta^(1-th)*NT*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )^(1/(1-th)) )^(1/(1-alpm));
MCT  = (alpm/PT)^(-alpm)*(MCN/(1-alpm))^(1-alpm);

ti2 = 1/th/( NT*IntT + ta^(1-th)*NT*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )*D;  @ multiplier for profit @

Lp   = L - f_E*N_TE - f_0*NT*sumc(DT01) - f_1*NT*sumc(DTH1+DTL1);  @ Labor in production @

V0i = ti2*exp(zs)/bet;     @ row (Z), cols (f) current period non-exporter  row(z_today), col(f_today) @
VHi = ti2*exp(zs)*tiH/bet;  @ row (Z), cols (f) current period exporter  row(z_today), col(f_today) @
VLi = ti2*exp(zs)*tiL/bet;  @ row (Z), cols (f) current period exporter  row(z_today), col(f_today) @

iter=1; do until iter>10;
   EV0 = bet*n_S(zs).*(P*V0i);  @ discounted expected value when m=0 row(z_today), col=1 @
   EVH = bet*n_S(zs).*(P*VHi);  @ discounted expected value when m=1 row(z_today), col=1 @
   EVL = bet*n_S(zs).*(P*VLi);  @ discounted expected value when m=1 row(z_today), col=1 @
    
   @ expected value after payments decision @

   EV0f = maxc( EV0'|( EVH'-W*f_0 ) );  @ taking max @
   EVHf = maxc( EV0'|( ( rhoH*EVH + (1-rhoH)*EVL )'- W*f_1) );  @ taking max @
   EVLf = maxc( EV0'|( ( (1-rhoL)*EVH + rhoL*EVL )'- W*f_1));  @ taking max @
      
   V0i_new = ti2*exp(zs) + EV0f;
   VHi_new = ti2*exp(zs)*tiH + EVHf;
   VLi_new = ti2*exp(zs)*tiL + EVLf;

   tol = maxc( abs( vec(V0i|VHi|VLi) - vec(V0i_new|VHi_new|VLi_new) ) );
   iter = 100*(tol.<1e-14);
   
   V0i = V0i_new;
   VHi = VHi_new;
   VLi = VLi_new;
   
endo;

EXY = ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL )/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )*D/Y; @ Export-GDP ratio @

K_T = alp*(1-alpm)*(th-1)/th/R*D/S;
L_T = (1-alp)/alp*R/W*K_T;

vSS1[1] = PT - 1;

vSS1[2] = -f_E*W + bet*(V0i'D_E);

vSS1[3] = K_T - K;

vSS1[4] = W*Lp + R*K + 1/((1-alp)*(1-alpm))/(th-1)*W*L_T + (ta-1)*EXY*Y - Y;
/*
vSS1[5] = gam*C^(sig) - W; 
*/

vSS1[5] = L - L0ss; 

retp(vSS1);
endp;
@=========================== END PROC SS1(x) ======================================================@






@=========================== BEGIN PROC SS0(x) ======================================================@
/*
   Compute the initial Steady State
*/

proc SS0(x);

local tol, i;
K   = exp(x[1]);  @ capital @
f_E = exp(x[2]);  @ entry sunk cost @
alp = exp(x[3]);  @ capital share parameter in production @
C   = exp(x[4]);  @ consumption @
W   = exp(x[5]);  @ Wage rate @

N_TE = n_E;    @ mass of tradable good entrants @

Y    = C + del*K;    @ Absorption @
D    = S*Y/( S-alpm*(th-1)/th );
MCN  = (R/alp)^(alp)*(W/(1-alp))^(1-alp);  
PT   = ( th/(th-1)*(MCN/(1-alpm))^(1-alpm)*alpm^(-alpm)*( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )^(1/(1-th)) )^(1/(1-alpm));
MCT  = (alpm/PT)^(-alpm)*(MCN/(1-alpm))^(1-alpm);

ti2 = 1/th/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )*D;  @ multiplier for profit @

f_0n = f_0/W*ti2;
f_1n = f_1/W*ti2;

Lp   = L - f_E*N_TE - f_0n*sumc(DT01) - f_1n*sumc(DTH1+DTL1);  @ Labor in production @

V0i = V0*ti2;
VLi = VL*ti2;
VHi = VH*ti2;

EXY = ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL )/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )*D/Y; @ Export-GDP ratio @

K_T = alp*(1-alpm)*(th-1)/th/R*D/S;
L_T = (1-alp)/alp*R/W*K_T;

vSS0[1] = PT - 1;

vSS0[2] = -f_E*W + bet*(V0i'D_E);
/*
vSS0[3] = W*L/Y - (1-alp0);

vSS0[3] = alp - alp0;
*/
vSS0[3] = alp - 0.13247214;  @ matching RhoHL value @

vSS0[4] = K_T - K;

vSS0[5] = W*Lp + R*K + 1/((1-alp)*(1-alpm))/(th-1)*W*L_T + (ta-1)*EXY*Y - Y;

retp(vSS0);
endp;
@=========================== END PROC SS0(x) ======================================================@






@--------------- BEGIN PROC n0n1nx(x) -------------------@
proc(3) = n0n1nx(xn0n1nx);
local iter, i, f_0t, f_1t, ti2;

f_0t = xn0n1nx[1];  @ W*f_0 @
f_1t = xn0n1nx[2];  @ W*f_1 @
ti2  = xn0n1nx[3];  @ multiplier for value (profit) @

V0 = 1/bet.*ti2.*exp(zs);      @ row (Z), cols (f) current period non-exporter  row(z_today), col(f_today) @
VH = 1/bet.*ti2.*exp(zs)*tiH;  @ row (Z), cols (f) current period exporter  row(z_today), col(f_today) @
VL = 1/bet.*ti2.*exp(zs)*tiL;  @ row (Z), cols (f) current period exporter  row(z_today), col(f_today) @


iter=1; do until iter>10;
   EV0 = bet*n_S(zs).*(P*V0);  @ discounted expected value when m=0 row(z_today), col=1 @
   EVH = bet*n_S(zs).*(P*VH); @ discounted expected value when m=1 row(z_today), col=1 @
   EVL = bet*n_S(zs).*(P*VL); @ discounted expected value when m=1 row(z_today), col=1 @
 
   @ expected value after payments decision @

   EV0f = maxc( EV0'|( EVH'-f_0t ) );  @ taking max @
   EVHf = maxc( EV0'|( ( rhoH*EVH + (1-rhoH)*EVL )'- f_1t ) );  @ taking max @
   EVLf = maxc( EV0'|( ( (1-rhoL)*EVH + rhoL*EVL )'- f_1t ) );  @ taking max @
      
   V0_new = ti2*exp(zs) + EV0f;
   VH_new = ti2*exp(zs)*tiH + EVHf;
   VL_new = ti2*exp(zs)*tiL + EVLf;

   tol = maxc( abs( vec(V0|VH|VL) - vec(V0_new|VH_new|VL_new) ) );
   iter = 100*(tol.<1e-10);

   V0 = V0_new;
   VH = VH_new;
   VL = VL_new;
endo;

DV0 = ( EVH - f_0t ) - EV0;
DVH = ( (rhoH*EVH + (1-rhoH)*EVL) - f_1t ) - EV0;
DVL = ( ((1-rhoL)*EVH + rhoL*EVL) - f_1t ) - EV0;

{z0,frac0,idx0,ms0}= Cutoff(DV0);
{zH,fracH,idxH,msH}= Cutoff(DVH);
{zL,fracL,idxL,msL}= Cutoff(DVL);


@------ Initial distribution rows(zs) -----@
DT0 = D_E;
DTH = 0*DT0;
DTL = 0.1*DT0;

iter=1; do until iter>10;
   
   @---- exporting decisions after cost shocks ----@
   DT00 = (1-ms0).*DT0;
   DT01 = ms0.*DT0;
   DTH0 = (1-msH).*DTH;
   DTH1 = msH.*DTH;
   DTL0 = (1-msL).*DTL;
   DTL1 = msL.*DTL;
   @---- innovation after survival and productivity shocks----@
   DT0new = P'( n_S(zs).*( DT00 + DTH0 + DTL0 ) ) + D_E; 
   DTHnew = P'( n_S(zs).*( DT01 + rhoH*DTH1 + (1-rhoL)*DTL1 ) ); 
   DTLnew = P'( n_S(zs).*( (1-rhoH)*DTH1 + rhoL*DTL1 ) ); 
   
   tol = maxc(abs( (DT0|DTL|DTH) - (DT0new|DTLnew|DTHnew) ) );
   iter = 100*(tol.<1e-10);

   DT0 = DT0new;
   DTH = DTHnew;
   DTL = DTLnew;
   
endo;

DT1 = DTH+DTL;

SD0  = P'( n_S(zs).*DT0 ); @ survived last period non-exporters @
SD01 = P'( n_S(zs).*DT01); @ survived starters @

SD10 = P'( n_S(zs).*( DTH0 + DTL0 ) );  @ survived last period exporters being non-exporters @
SD1H = P'( n_S(zs).*( rhoH*DTH1 + (1-rhoL)*DTL1 ) ); @ survived last period exporters being H @
SD1L = P'( n_S(zs).*( (1-rhoH)*DTH1 + rhoL*DTL1 ) ); @ survived last period exporters being L @

n_0 = sumc(SD01)/sumc(SD0);                     @ starter rate @
n_1 = sumc(SD10)/sumc(SD10+SD1H+SD1L);          @ stopper rate @
n_X = sumc(DT1)/sumc(DT0+DT1);                  @ exporter ratio @


retp(n_0,n_1,n_X);
endp;
@--------------- END PROC n0n1nx(x) -------------------@

























@--------------- BEGIN PROC simul(x) -------------------@
proc(1)= simul(paras);

sde  = paras[1];
rho  = paras[2]; 
nd0  = paras[3];
muE  = paras[4];
xiH  = paras[5];
xiL  = paras[6];
rhoH = paras[7];
rhoL = paras[8];
Prob0= paras[9];
f_0  = paras[10];
f_1  = paras[11];

if rhoLH==1; rhoL = rhoH; endif;

zp0 = cdfni(prob0)*sdz+muE;  @ entrant's production cut off @
zpH = zp0; @ to be calculated @
zpL = zp0; @ to be calculated @

/*  
@-------  Find xiL to match year-5 intensity ---@
convtol=di;    prntit=0;
vxiL=ones(1,1);
x1 = nlsys(&findxiL,ln(xiL),jc0,convtol,prntit,prntout);
*/
tiH = ( 1 + ta^(-th)*xiH^(1-th) ); @ multiplier for exporters with H @
tiL = ( 1 + ta^(-th)*xiL^(1-th) ); @ multiplier for exporters with L @

@-----------------------------------------------------------------@
@------ Computing unconditional and Conditional Distribution -----@
@-----------------------------------------------------------------@
sdz  = sqrt(sde^2/(1-rho^2));            @ Unconditional SD conditional on survival @
nodes  = 200;                            @ # of Nodes for discritization @
inprob = 1e-8;                           @ initial node set up cdfni(m)*sqrt(sde^2/(1-rho^2)) @

y1     = cdfni(inprob)*sde*1.5;          @ lowest value for z @ 
yN     = -cdfni(inprob)*sde*1.5;         @ highest value for z@
ome     = (yN-y1)/(nodes-1);             @ interval @
zs     = seqa(y1,ome,nodes);             @ nodes @
zsL    = zs-ome/2;                       @ min points @

@----- Computing Transition matrix ------@
P     = zeros(nodes,nodes);              @ Transition matrix pjk = Pr(yk|yj) @
j=1; do until j>nodes;
   k=1; do until k>nodes;
      P[j,k] = cdfn( (zs[k]-rho*zs[j]+ome/2)/sde ) - cdfn( (zs[k]-rho*zs[j]-ome/2)/sde );
      if P[j,k]<1e-10; P[j,k]=0; endif;
   k=k+1; endo;
j=j+1; endo;
P = P./(sumc(P'));                       @ Transition Matrix @

@------ Entrant' distribution: mass normalized to 1 -------@
D_E = zeros(nodes,1);
j=1; do until j>nodes;
  D_E[j] = cdfn( (zs[j]+muE+ome/2)/sdz ) - cdfn( (zs[j]+muE-ome/2)/sdz );
j=j+1; endo;
D_E = D_E/(sumc(D_E));

@ Finding the value functions given f_0 and f_1 @
V0HL = Val0HL(ln(f_0|f_1));

V0 = V0HL[.,1];
VH = V0HL[.,2];
VL = V0HL[.,3];

DV0 = ( EVH - f_0 ) - EV0;
DVH = ( (rhoH*EVH + (1-rhoH)*EVL) - f_1 ) - EV0;
DVL = ( ((1-rhoL)*EVH + rhoL*EVL) - f_1 ) - EV0;

{z0,frac0,idx0,ms0}= Cutoff(DV0);
{zH,fracH,idxH,msH}= Cutoff(DVH);
{zL,fracL,idxL,msL}= Cutoff(DVL);

@------ Initial distribution rows(zs) -----@
DT0 = D_E;
DTH = 0*DT0;
DTL = 0.1*DT0;

iter=1; do until iter>10;
   
   @---- exporting decisions after cost shocks ----@
   DT00 = (1-ms0).*DT0;
   DT01 = ms0.*DT0;
   DTH0 = (1-msH).*DTH;
   DTH1 = msH.*DTH;
   DTL0 = (1-msL).*DTL;
   DTL1 = msL.*DTL;
   @---- innovation after survival and productivity shocks----@
   DT0new = P'( n_S(zs).*( DT00 + DTH0 + DTL0 ) ) + D_E; 
   DTHnew = P'( n_S(zs).*( DT01 + rhoH*DTH1 + (1-rhoL)*DTL1 ) ); 
   DTLnew = P'( n_S(zs).*( (1-rhoH)*DTH1 + rhoL*DTL1 ) ); 
   
   tol = maxc(abs( (DT0|DTL|DTH) - (DT0new|DTLnew|DTHnew) ) );
   iter = 100*(tol.<1e-14);
   
   DT0 = DT0new;
   DTH = DTHnew;
   DTL = DTLnew;
   
endo;

DT1 = DTH+DTL;

SD0  = P'( n_S(zs).*DT0 ); @ survived last period non-exporters @
SD01 = P'( n_S(zs).*DT01); @ survived starters @

SD10 = P'( n_S(zs).*( DTH0 + DTL0 ) );               @ survived last period exporters being non-exporters @
SD1H = P'( n_S(zs).*( rhoH*DTH1 + (1-rhoL)*DTL1 ) ); @ survived last period exporters being H @
SD1L = P'( n_S(zs).*( (1-rhoH)*DTH1 + rhoL*DTL1 ) ); @ survived last period exporters being L @

n_0 = sumc(SD01)/sumc(SD0);                     @ starter rate @
n_1 = sumc(SD10)/sumc(SD10+SD1H+SD1L);          @ stopper rate @
n_X = sumc(DT1)/sumc(DT0+DT1);                  @ exporter ratio @

@---- 5-year exit ----@
DE0s  = D_E;
DEHs = 0*DE0s;
DELs = 0*DE0s;

iter=1; do until iter>5;
   @---- exporting decisions after cost shocks ----@
   DE00 = (1-ms0).*DE0s[.,iter];
   DE01 = ms0.*DE0s[.,iter];
   DEH0 = (1-msH).*DEHs[.,iter];
   DEH1 = msH.*DEHs[.,iter];
   DEL0 = (1-msL).*DELs[.,iter];
   DEL1 = msL.*DELs[.,iter];
   @---- innovation after survival and productivity shocks----@
   DE0new = P'( n_S(zs).*( DE00 + DEH0 + DEL0 ) ); 
   DEHnew = P'( n_S(zs).*( DE01 + rhoH*DEH1 + (1-rhoL)*DEL1 ) ); 
   DELnew = P'( n_S(zs).*( (1-rhoH)*DEH1 + rhoL*DEL1 ) ); 

   DE0s = DE0s~DE0new;
   DEHs = DEHs~DEHnew;
   DELs = DELs~DELnew;
iter = iter+1; endo;
Exit5 = 1-sumc(DE0s[.,6]|DEHs[.,6]|DELs[.,6])/sumc(DE0s[.,1]|DEHs[.,1]|DELs[.,1]);


@------ eei ------@
Int0 = exp(zs)'DT0;    @ Integration for nontraded goods       @ 
IntH = exp(zs)'DTH;    @ Integration for traded goods with xiH @   
IntL = exp(zs)'DTL;    @ Integration for traded goods with xiL @   
IntT = Int0+IntH+IntL;  
eei  = ta^(-th)*( xiL^(1-th)*IntL + xiH^(1-th)*IntH )/( IntL + IntH + ta^(-th)*( xiL^(1-th)*IntL + xiH^(1-th)*IntH ) ); @ intensity of all @

@----------  Labor -------------@
L_0 = exp(zs);       @ normalized labor @
L_L = exp(zs)*tiL;
L_H = exp(zs)*tiH;

L_T = L_0'DT0 + L_H'DTH + L_L'DTL;  @ Total Labor @
Ly0 = L_0'D_E;          @ 0-year labor @

DDT00 = DT00 - (n_S(zs).*DT00); @ shutdown plants of 00 @
DDT01 = DT01 - (n_S(zs).*DT01); @ shutdown plants of 01 @

DDTH0 = DTH0 - (n_S(zs).*DTH0); @ shutdown plants of H0 @
DDTH1 = DTH1 - (n_S(zs).*DTH1); @ shutdown plants of H1 @

DDTL0 = DTL0 - (n_S(zs).*DTL0); @ shutdown plants of L0 @
DDTL1 = DTL1 - (n_S(zs).*DTL1); @ shutdown plants of L1 @

Ld0 = L_0'(DDT00+DDT01) + L_H'(DDTH0+DDTH1) + L_L'(DDTL0+DDTL1);  @ Shutdown plants' labor @

shutdown = sumc(D_E)/sumc(DT0+DTH+DTL);

@===================================@
@===     EMPLOYMENT DISTRIBUTION ===@
@===================================@
wgtL  =  L1992/E1992*sumc(DT0+DT1)/L_T;

L_0D = (L_0*wgtL)~(DT0/sumc(DT0+DT1));
L_LD = (L_L*wgtL)~(DTL/sumc(DT0+DT1));
L_HD = (L_H*wgtL)~(DTH/sumc(DT0+DT1));

L_cof = 5|10|20|50|100|250|500|1000|2500;

i=1; do until i>rows(L_cof);
   if i==1;
      L_cmfe = sumc(L_0D[.,2].*(L_0D[.,1].<L_cof[i])) + sumc(L_LD[.,2].*(L_LD[.,1].<L_cof[i])) + sumc(L_HD[.,2].*(L_HD[.,1].<L_cof[i]));  @ Establishment @
      L_cmfl = sumc((L_0D[.,1].*L_0D[.,2]).*(L_0D[.,1].<L_cof[i])) + sumc((L_LD[.,1].*L_LD[.,2]).*(L_LD[.,1].<L_cof[i]))
               + sumc((L_HD[.,1].*L_HD[.,2]).*(L_HD[.,1].<L_cof[i])); @ Employment @
      L_pmfe = L_cmfe;
      L_pmfl = L_cmfl;
   else;
      L_cmfe = L_cmfe|( sumc(L_0D[.,2].*(L_0D[.,1].<L_cof[i])) + sumc(L_LD[.,2].*(L_LD[.,1].<L_cof[i]))
                        + sumc(L_HD[.,2].*(L_HD[.,1].<L_cof[i])) );
      L_cmfl = L_cmfl|( sumc((L_0D[.,1].*L_0D[.,2]).*(L_0D[.,1].<L_cof[i])) + sumc((L_LD[.,1].*L_LD[.,2]).*(L_LD[.,1].<L_cof[i])) 
                        + sumc((L_HD[.,1].*L_HD[.,2]).*(L_HD[.,1].<L_cof[i])) );
      L_pmfe = L_pmfe|(L_cmfe[i]-L_cmfe[i-1]);
      L_pmfl = L_pmfl|(L_cmfl[i]-L_cmfl[i-1]);
   endif;
i=i+1; endo;
L_cmfe = L_cmfe|(sumc(L_0D[.,2]+L_LD[.,2]+L_HD[.,2]));
L_pmfe = L_pmfe|(L_cmfe[rows(L_cmfe)]-L_cmfe[rows(L_cmfe)-1]);

L_cmfl = L_cmfl|(L_0D[.,1]'L_0D[.,2]+L_LD[.,1]'L_LD[.,2]+L_HD[.,1]'L_HD[.,2]);
L_pmfl = L_pmfl|(L_cmfl[rows(L_cmfl)]-L_cmfl[rows(L_cmfl)-1]);

L_pmfl = L_pmfl/L_cmfl[rows(L_cmfl)];
L_cmfl = L_cmfl/L_cmfl[rows(L_cmfl)];

@============ Export participation rate distribution ==========@

L_cofx = 100|250|500|1000|2500;

i=1; do until i>rows(L_cofx);
   if i==1;
      L_cmf3 = sumc(L_0D[.,2].*(L_0D[.,1].<L_cofx[i])) + sumc(L_LD[.,2].*(L_LD[.,1].<L_cofx[i]))
               + sumc(L_HD[.,2].*(L_HD[.,1].<L_cofx[i])); @ All Establishment mass @
      L_cmf4 = sumc(L_LD[.,2].*(L_LD[.,1].<L_cofx[i])) + sumc(L_HD[.,2].*(L_HD[.,1].<L_cofx[i])); @ Exporter establishement mass @
      L_cmfx = L_cmf4/L_cmf3;                               @ Exporter share CMF (Establishment) @
      L_pmf3 = L_cmf3;
      L_pmf4 = L_cmf4;
      L_pmfx = L_cmfx;   
   else;
      L_cmf3 = L_cmf3|( sumc(L_0D[.,2].*(L_0D[.,1].<L_cofx[i])) + sumc(L_LD[.,2].*(L_LD[.,1].<L_cofx[i])) 
                         + sumc(L_HD[.,2].*(L_HD[.,1].<L_cofx[i])) );
      L_cmf4 = L_cmf4|( sumc(L_LD[.,2].*(L_LD[.,1].<L_cofx[i])) + sumc(L_HD[.,2].*(L_HD[.,1].<L_cofx[i])) );
      L_cmfx = L_cmfx|(L_cmf4/L_cmf3);
      L_pmf3 = L_pmf3|(L_cmf3[i]-L_cmf3[i-1]);
      L_pmf4 = L_pmf4|(L_cmf4[i]-L_cmf4[i-1]);
      L_pmfx = L_pmfx|(L_pmf4[i]/L_pmf3[i]);
   endif;
i=i+1; endo;

L_cmf3 = L_cmf3|(sumc(L_0D[.,2]+L_LD[.,2]+L_HD[.,2]));
L_pmf3 = L_pmf3|(L_cmf3[rows(L_cmf3)]-L_cmf3[rows(L_cmf3)-1]);

L_cmf4 = L_cmf4|(sumc(L_LD[.,2]+L_HD[.,2]));
L_pmf4 = L_pmf4|(L_cmf4[rows(L_cmf4)]-L_cmf4[rows(L_cmf4)-1]);

L_cmfx = L_cmfx|(L_cmf4[rows(L_cmf4)]/L_cmf3[rows(L_cmf3)]);
L_pmfx = L_pmfx|(L_pmf4[rows(L_pmf4)]/L_pmf3[rows(L_pmf4)]);



retp(paras);
endp;
@--------------- END PROC simul(x) -------------------@




@--------------- BEGIN PROC Val0HL(x) -------------------@
@     Values, and f_0 & f_1 are normalized               @
@     Returns the values given f_T, f_0 and f_1          @
@--------------------------------------------------------@
proc Val0HL(xf01);

   local i, iter, tol;
   f_0 = exp(xf01[1]);     @ f_0 @
   f_1 = exp(xf01[2]);     @ f_1 @

   @--- Initial values: to be corrected ---@
   V0 = 1/bet.*exp(zs);      @ current period non-exporter   row(z_today) @
   VH = 1/bet.*exp(zs)*tiH;  @ current period xiH exporter   row(z_today) @
   VL = 1/bet.*exp(zs)*tiL;  @ current period xiL exporter   row(z_today) @

   iter=1; do until iter>10;
      EV0 = bet*n_S(zs).*(P*V0);  @ discounted expected value when m=0 row(z_today), col=1 @
      EVH = bet*n_S(zs).*(P*VH);  @ discounted expected value when m=1 row(z_today), col=1 @
      EVL = bet*n_S(zs).*(P*VL);  @ discounted expected value when m=1 row(z_today), col=1 @
      
      @ expected value after payments decision @

      EV0f = maxc(EV0'|(EVH'-f_0));  @ taking max @
      EVHf = maxc(EV0'|( (rhoH*EVH + (1-rhoH)*EVL)'-f_1 ));  @ taking max @
      EVLf = maxc(EV0'|( ((1-rhoL)*EVH + rhoL*EVL)'-f_1 ));  @ taking max @
      
      V0_new = exp(zs) + EV0f;
      VH_new = exp(zs)*tiH + EVHf;
      VL_new = exp(zs)*tiL + EVLf;

      tol = maxc( abs( vec(V0|VH|VL) - vec(V0_new|VH_new|VL_new) ) );
      iter = 100*(tol.<1e-10);
      V0 = V0_new;
      VH = VH_new;
      VL = VL_new;
      @tol;@
   endo;
retp(V0~VH~VL);
endp;
@--------------- END PROC Val0HL(x) -------------------@



@--------------- BEGIN PROC Cutoff(x) -------------------@
@---- Given Val, find Val(i)=0, and fraction   ----------@
@--------------------------------------------------------@
proc(4)= Cutoff(Val);

   local fracV, zcut, ind0, ms;
   ind0 = sumc(Val.<=0);
   if ind0==0;
      zcut = zs[1] - Val[1]*(zs[2]-zs[1])/(Val[2]-Val[1]);
      zcut = maxc(zcut|(zs[1]-ome/2));  @ take min(zs)-ome/2 @ 
      ind0 = 1;  @ index for adding fraction @
      fracV = (zs[1]+ome/2-zcut)/ome;
   endif;
   if ind0==nodes; @ extrapolate @
      zcut = zs[nodes-1] - Val[nodes-1]*(zs[nodes]-zs[nodes-1])/(Val[nodes]-Val[nodes-1]);
      zcut = minc(zcut|(zs[nodes]+ome/2));  
      ind0 = nodes;
      fracV = (zs[ind0]+ome/2-zcut)/ome;
   endif;
   if (ind0>0).and (ind0<nodes); @ take linear interpolation @
      zcut = zs[ind0] - Val[ind0]*(zs[ind0+1]-zs[ind0])/(Val[ind0+1]-Val[ind0]);
      ind0 = sumc((zs-ome/2).<zcut);
      fracV = (zs[ind0]+ome/2-zcut)/ome;
   endif;
   ms = ((zs-ome/2).>zcut);
   ms[ind0] = fracV;
retp(zcut,fracV,ind0,ms);   
endp;
@--------------- END PROC Cutoff(x) -------------------@




@--------------- BEGIN PROC n_S(x) -------------------@
@  Finding shutdown probability given nd0 and lamD    @
@-----------------------------------------------------@
proc n_S(x);
   local nS;
   nS = 1-exp(-lamD*exp(x));  @ probability of survival @
   nS = nS - nd0;     
   nS = maxc((nS')|zeros(1,rows(nS)));
   nS = minc((nS')|ones(1,rows(nS)));
  
retp(nS);
endp;
@--------------- END PROC n_S(x) -------------------@




@--------------- BEGIN PROC findxiL(x) -------------------@
@ find xiL to get E(intensity 5-year of exporting) = eei5 @
@ initial exporting = year 0                              @
@---------------------------------------------------------@
proc findxiL(x);
   local ip;
   xiL = exp(x);

   dH=1; @ mass of H : start with H @
   dL=0; @ mass of L : start with H @
   ip = 1; do until ip>15;
      dH = dH|( dH[ip]*rhoH + dL[ip]*(1-rhoL) );
      dL = dL|( dH[ip]*(1-rhoH) + dL[ip]*rhoL );
   ip = ip+1; endo;
   Eintensity = dH.*ta^(-th)*xiH^(1-th)/( 1 + ta^(-th)*xiH^(1-th) ) + dL.*ta^(-th)*xiL^(1-th)/( 1 + ta^(-th)*xiL^(1-th) );
   
   @vxiL[1] =  Eintensity[5] - eei5;@
   vxiL[1] =  Eintensity[5] - Eintensity[1]*2;

retp(vxiL);
endp;
@--------------- END PROC findxiL(x) -------------------@


















@--------------- BEGIN PROC Paraall(x) -------------------@
proc(1)= Paraall(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
lamD = exp(xft01[3]);
rhoH = exp(xft01[4]);
nd0  = exp(xft01[5]);
muE  = exp(xft01[6]);
rho  = 1-exp(xft01[7]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = Exit5 - Exit50;
vfT01[4] = eei - eei0;
vfT01[5] = Ly0/L_T - Ly00;
vfT01[6] = Ld0/L_T - Ld00;

esum = meanc(((pmfe_dat-L_pmfe)/distwgt)^2);
@lsum = sumc(((pmfl_dat-L_pmfl)/distwgt)^2);@

retp((vfT01'vfT01)*ndistwgt+esum@+lsum@);
endp;
@--------------- END PROC Paraall(x) -------------------@

@--------------- BEGIN PROC fT01all1(x) -------------------@
proc(1)= fT01all1(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
lamD = exp(xft01[3]);
rhoH = exp(xft01[4]);
nd0  = exp(xft01[5]);
muE  = exp(xft01[6]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = Exit5 - Exit50;
vfT01[4] = eei - eei0;
vfT01[5] = Ly0/L_T - Ly00;
vfT01[6] = Ld0/L_T - Ld00;

@esum = meanc(((pmfe_dat-L_pmfe)/distwgt)^2);@
@lsum = sumc(((pmfl_dat-L_pmfl)/distwgt)^2);@

retp((vfT01'vfT01*10));
endp;
@--------------- END PROC fT01all1(x) -------------------@



@--------------- BEGIN PROC fT01(x) -------------------@
proc(1)= fT01(xft01);
local esum, lsum;

f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01(x) -------------------@


@--------------- BEGIN PROC fT01rhoHxiH(x) -------------------@
proc(1)= fT01rhoHxiH(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
rhoH = exp(xft01[3]);
xiH  = exp(xft01[4]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

Eintensityall = DTH.*ta^(-th)*xiH^(1-th)/( 1 + ta^(-th)*xiH^(1-th) ) + DTL.*ta^(-th)*xiL^(1-th)/( 1 + ta^(-th)*xiL^(1-th) );
Eintensityall = sumc(Eintensityall)/sumc(DTH+DTL);
EEi00 = ta^(-th)*xiH^(1-th)/( 1 + ta^(-th)*xiH^(1-th) );

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = eei - eei0;
vfT01[4] = EEi00 - Eintensityall*0.5; 

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01rhoH(x) -------------------@


@--------------- BEGIN PROC fT01rhoH(x) -------------------@
proc(1)= fT01rhoH(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
rhoH = exp(xft01[3]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = eei - eei0;

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01rhoH(x) -------------------@


@--------------- BEGIN PROC lamndmu(x) -------------------@
proc(1)= lamndmu(xft01);
lamD = exp(xft01[1]);
nd0  = exp(xft01[2]);
muE  = exp(xft01[3]);

if rhoLH==1; rhoL = rhoH; endif;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

vfT01[1] = Exit5 - Exit50;
vfT01[2] = Ly0/L_T - Ly00;
vfT01[3] = Ld0/L_T - Ld00;

retp((vfT01'vfT01*10));
endp;
@--------------- END PROC lamndmu(x) -------------------@









@--------------- BEGIN PROC fT01xiH(x) -------------------@
proc(1)= fT01xiH(xft01);
local esum, lsum;
f_0 = exp(xft01[1]) + exp(xft01[2]);
f_1 = exp(xft01[2]);
xiH  = exp(xft01[3]);

xi = xiH;
xiL = xiH;

para = sde|rho|nd0|muE|xiH|xiL|rhoH|rhoL|prob0|f_0|f_1;
{para1}=simul(para);

S    = ( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )/( IntT + ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) );
EXY = ta^(-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL )/( IntT + ta^(1-th)*( xiH^(1-th)*IntH + xiL^(1-th)*IntL ) )*S/( S-alpm*(th-1)/th ); @ Export-GDP ratio @

vfT01[1] = n_x0 - n_x;
vfT01[2] = n_1 - n_10;
vfT01[3] = (EXY - TR_bench)*10; 

retp(vfT01'vfT01);
endp;
@--------------- END PROC fT01xiH(x) -------------------@
